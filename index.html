<!DOCTYPE html>

<html dir="rtl" lang="he">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>רמיקוב – ניקוד + אימון (CPU)</title>
<style>
  :root{
    --bg:#0f1724; --panel:#121c2b; --muted:#9fb3c8; --text:#eaf6ff;
    --acc:#89e3ff; --good:#2ecc71; --bad:#c14949;
  }
  html,body{height:100%}
  body{margin:0;background:linear-gradient(180deg,#0b1420,#0e1623 40%,#0b1420);
       color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji",sans-serif}
  .wrap{max-width:920px;margin:0 auto;padding:14px 14px 48px}
  .row{display:flex;flex-wrap:wrap;gap:12px}
  .pill{display:inline-flex;align-items:center;gap:.5rem;padding:.35rem .7rem;border-radius:999px;background:#122235;color:#d7edff;font-size:.9rem}
  .muted{color:var(--muted)}
  h2{margin:.6rem 0 0.2rem;font-size:1.35rem}
  h3{margin:1rem 0 .4rem;font-size:1.1rem;color:#cfeaff}
  .card{background:var(--panel);border-radius:14px;padding:14px;box-shadow:0 6px 24px rgba(0,0,0,.25);margin:10px 0}
  .board .thead, .board .row{display:grid;grid-template-columns:42px 1fr 100px 190px;gap:10px;align-items:center}
  .board .thead{opacity:.8;padding-bottom:6px;border-bottom:1px solid #1e2a3c}
  .board .row{padding:6px 0;border-bottom:1px dashed #1a2537}
  .btn{border:0;border-radius:10px;padding:.48rem .7rem;background:#16314a;color:#e9f6ff;cursor:pointer}
  .btn:hover{filter:brightness(1.1)}
  .btn.bad{background:#3a1e26;color:#ffc7c7}
  .btn.good{background:#113021;color:#c6ffd9}
  .btn.acc{background:#14344a;color:#bfefff}
  .btn.cam{display:inline-flex;gap:.35rem;align-items:center}
  input[type="text"], input[type="number"]{width:100%;padding:.48rem .6rem;border-radius:10px;background:#0d1522;border:1px solid #1c2a3c;color:#eaf6ff}
  .hint{font-size:.85rem;color:#94adc4}
  .grid2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  .kbd{background:#0b1420;border:1px solid #203049;padding:.15rem .45rem;border-radius:6px}
  .sep{height:1px;background:#1a2738;margin:.75rem 0}
  .footer{position:sticky;bottom:0;backdrop-filter:blur(8px);background:rgba(8,13,22,.75);border-top:1px solid #22324a;padding:10px;margin:0 -14px}
  small.tag{background:#0f263a;color:#d2f1ff;border:1px solid #234761;border-radius:999px;padding:.15rem .55rem;margin-inline-end:.35rem}
  .ghost{opacity:.35}
  .flex{display:flex;gap:.5rem;align-items:center}
  .btn.inline{padding:.35rem .55rem;border-radius:8px}
  .nowrap{white-space:nowrap}
  .danger{color:#ffb2b2}
  .ok{color:#baffc3}
  .scrollx{overflow:auto}
  .copybtn{margin-inline-start:.5rem}
</style>
</head>
<body>
<div class="wrap" id="app">
<div class="row" style="justify-content:space-between;align-items:center">
<div class="flex">
<small class="tag" id="verBadge">v5.13-ml</small>
<small class="tag" id="tfBadge">TF: init</small>
<small class="tag" id="modelBadge">model: —</small>
<small class="tag" id="examplesBadge">דוגמאות: —</small>
</div>
<div class="flex">
<button class="btn inline" id="btnResetScores">איפוס נקודות</button>
<button class="btn inline" id="btnSaveNames">שמור שמות</button>
</div>
</div>
<!-- לוח הובלה יחיד -->
<div class="card board" id="leaderCard">
<div class="row" style="justify-content:space-between;align-items:center">
<h2 style="margin:0">לוח הובלה</h2>
<div class="hint"><span class="kbd">+10</span>/<span class="kbd">-10</span> תעדכן נקודות, או הוסיפו ידנית.</div>
</div>
<div class="thead">
<div>#</div>
<div>שם</div>
<div>נקודות</div>
<div>פעולות</div>
</div>
<div id="boardRows"></div>
</div>
<!-- בחירת משתתפים -->
<div class="card">
<h2>בחירת משתתפים (עד 4)</h2>
<div class="grid2">
<div><label class="hint">שחקן 1</label><input id="p1" placeholder="שם" type="text"/></div>
<div><label class="hint">שחקן 2</label><input id="p2" placeholder="שם" type="text"/></div>
<div><label class="hint">שחקן 3</label><input id="p3" placeholder="שם" type="text"/></div>
<div><label class="hint">שחקן 4</label><input id="p4" placeholder="שם" type="text"/></div>
</div>
<div class="row" style="margin-top:10px">
<button class="btn acc" id="btnStart">התחל משחק</button>
<div class="hint">השמות נשמרים מקומית.</div>
</div>
</div>
<!-- אימון מודל – תמיד גלוי (על המכשיר) -->
<div class="card" id="trainCard">
<div id="lastDetectWrap" style="position:sticky;bottom:0;z-index:5;background:#0d1117;border-top:1px solid #263040;padding:8px 12px;display:flex;gap:12px;align-items:center"><div id="lastDetectLabel">זיהוי אחרון: —</div><img id="lastDetectImg" style="height:48px;width:36px;object-fit:cover;border-radius:6px;display:none"/></div><h2>אימון מודל זיהוי (CPU)</h2>
<div class="hint">upload → embedding (MobileNet) → KNN • המודל נשמר/נטען מ־localStorage (לא נשלח לרשת).</div>
<div class="sep"></div>
<div class="row" style="align-items:center;gap:10px">
<label class="hint">בחר/י מחלקה (מספר):</label>
<input id="classId" max="4" min="1" style="width:5rem" type="number" value="1"/>
<button class="btn inline" id="btnNukeExamples">נקה הכל</button>
<button class="btn inline" id="btnInitModel">אתחל מודל</button>
<button class="btn inline" id="btnSaveModel">שמור מודל</button>
<button class="btn inline" id="btnLoadModel">שחזר מודל</button>
<button class="btn inline" id="btnExportJSON">JSON ייצא</button>
<label class="btn inline nowrap">
        ייבא JSON
        <input accept="application/json" hidden="" id="jsonIn" type="file"/>
</label>
<span class="hint">מצב: <span id="statusSpan">מוכן</span></span>
</div>
<div class="row" style="margin-top:10px;align-items:center;gap:10px">
<label class="btn inline nowrap">
        הוסף מגז’יר (גלריה)
        <input accept="image/*" hidden="" id="filePick" multiple="" type="file"/>
</label>
<label class="btn inline nowrap">
        צילום מהמצלמה
        <input accept="image/*" capture="environment" hidden="" id="filePickCam" type="file"/>
</label>
</div>
<div class="sep"></div>
<div class="scrollx">
<pre id="debug" style="min-height:80px;margin:0;background:#0b1420;border:1px solid #22324a;border-radius:12px;padding:10px;white-space:pre-wrap"></pre>
</div>
</div>
<div class="footer row" style="justify-content:space-between">
<div class="hint">קיצור דרך: <span class="kbd">שמור מודל</span> שומר ל־localStorage • <span class="kbd">שחזר מודל</span> טוען אוטומטית עם פתיחת העמוד.</div>
<div class="muted">© v5.13-ml</div>
</div>
</div>
<!-- TFJS + MobileNet + KNN (גרסאות שנבדקו) -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js">
// === הוספת נקודות מהזיהוי לשחקן ===
function awardPointsFromDetection(playerIdx, points) {
  try {
    if (typeof points !== 'number' || !isFinite(points) || points <= 0) return;
    if (Array.isArray(window.players) && window.players[playerIdx]) {
      window.players[playerIdx].score = (window.players[playerIdx].score || 0) + points;
    }
    // עדכון UI אם יש
    let row = document.querySelectorAll('.board-row')[playerIdx];
    let scoreEl = row ? row.querySelector('.score') : null;
    if (scoreEl) {
      const newScore = window.players[playerIdx].score;
      scoreEl.textContent = newScore;
    }
    // הצגה בתחתית
    const lastDetLabel = document.getElementById('lastDetectLabel');
    if (lastDetLabel) {
      const pName = window.players[playerIdx]?.name || `שחקן ${playerIdx+1}`;
      lastDetLabel.textContent = `נוסף לשחקן “${pName}” ${points} נק׳ (סה״כ ${window.players[playerIdx].score})`;
    }
  } catch(err) {
    console.error("awardPointsFromDetection error", err);
  }
}


// === Multi‑tile helpers (non-destructive) ===
function __rk_toGray(r,g,b){ return (r*0.299 + g*0.587 + b*0.114) |0; }
function __rk_otsu(gray, w, h){
  const hist = new Array(256).fill(0); for(let i=0;i<gray.length;i++) hist[gray[i]]++;
  const total = w*h; let sum=0; for(let t=0;t<256;t++) sum += t*hist[t];
  let sumB=0, wB=0, wF=0, varMax=0, thr=0;
  for(let t=0;t<256;t++){ wB += hist[t]; if(wB===0) continue; wF = total - wB; if(wF===0) break;
    sumB += t*hist[t]; const mB = sumB / wB; const mF = (sum - sumB) / wF;
    const between = wB*wF*(mB-mF)*(mB-mF); if (between > varMax){ varMax = between; thr = t; } }
  return thr;
}
// returns {boxes:[{x,y,w,h}], ox, oy, nw, nh}
function __rk_segment(img, options){
  const cvs = document.createElement('canvas'), ctx = cvs.getContext('2d');
  const CW = 960, CH = 540; cvs.width=CW; cvs.height=CH;
  const scale = Math.min(CW/img.width, CH/img.height);
  const nw = Math.round(img.width*scale), nh = Math.round(img.height*scale);
  const ox = Math.round((CW - nw)/2), oy = Math.round((CH - nh)/2);
  ctx.clearRect(0,0,CW,CH); ctx.drawImage(img, ox, oy, nw, nh);

  const id = ctx.getImageData(ox, oy, nw, nh), data = id.data;
  const gray = new Uint8ClampedArray(nw*nh);
  for(let y=0;y<nh;y++){ for(let x=0;x<nw;x++){
    const i = (y*nw + x)*4; const r=data[i], g=data[i+1], b=data[i+2];
    gray[y*nw+x] = options.ignoreColor ? __rk_toGray(r,g,b) : Math.max(r,g,b);
  }};
  const thr = options.thr>0? options.thr : __rk_otsu(gray, nw, nh);
  const bin = new Uint8Array(nw*nh);
  for(let i=0;i<gray.length;i++) bin[i] = gray[i] > thr ? 1 : 0;

  const labels = new Int32Array(nw*nh).fill(-1);
  const boxes = []; const qx=[], qy=[]; let label=0;
  for(let y=0;y<nh;y++){ for(let x=0;x<nw;x++){
    const idx = y*nw + x; if(bin[idx]===0 || labels[idx]!==-1) continue;
    let minx=x, miny=y, maxx=x, maxy=y, area=0; qx.length=0; qy.length=0; qx.push(x); qy.push(y); labels[idx]=label;
    while(qx.length){ const cx=qx.pop(), cy=qy.pop(); const cidx=cy*nw+cx; area++;
      if(cx<minx) minx=cx; if(cy<miny) miny=cy; if(cx>maxx) maxx=cx; if(cy>maxy) maxy=cy;
      const nbs=[[1,0],[-1,0],[0,1],[0,-1]];
      for(const [dx,dy] of nbs){ const nx=cx+dx, ny=cy+dy; if(nx<0||ny<0||nx>=nw||ny>=nh) continue;
        const nidx=ny*nw+nx; if(bin[nidx]===1 && labels[nidx]===-1){ labels[nidx]=label; qx.push(nx); qy.push(ny); } }
    }
    const bw=maxx-minx+1, bh=maxy-miny+1; const aspect = Math.min(bw,bh)/Math.max(bw,bh);
    if(area>= (options.minArea||1600) && aspect>= (options.aspectMin||0.5) && aspect<= (options.aspectMax||1.0)){
      boxes.push({x:minx,y:miny,w:bw,h:bh,area,aspect});
    }
    label++;
  }}
  boxes.sort((a,b)=> a.y===b.y ? a.x-b.x : a.y-b.y);
  if(boxes.length>(options.maxCount||12)) boxes.length = (options.maxCount||12);
  return {boxes, ox, oy, nw, nh, CW, CH};
}
// classify crops and return {values:[...], sum, details:[{n,conf}]}
async function __rk_classifyCropsFromSeg(seg){
  await ensureModels?.();
  const off = document.createElement('canvas'); off.width=112; off.height=112; const oc = off.getContext('2d');
  let sum=0, values=[], details=[];
  for(let i=0;i<seg.boxes.length;i++){
    const b = seg.boxes[i]; const pad = Math.floor(Math.min(b.w,b.h)*0.08);
    // draw original image (held in last image loaded in previous step): we don't have it here; we'll reconstruct from stage if exists
    const stage = document.getElementById('stage');
    if(!stage){ continue; }
    oc.clearRect(0,0,112,112);
    oc.drawImage(stage, seg.ox + b.x - pad, seg.oy + b.y - pad, b.w + pad*2, b.h + pad*2, 0,0,112,112);
    try{
      const feat = net.infer(off, 'conv_preds');
      const res = await classifier.predictClass(feat, 3);
      if(res && res.label!=null){
        const v = parseInt(res.label,10);
        const cfs = Object.values(res.confidences||{}); const conf = Math.round(Math.max(...cfs)*100);
        if(Number.isFinite(v)){ values.push(v); sum += v; details.push({n:v, conf}); }
      }
    }catch(err){ try{ log && log('multi: classify error '+(err?.message||err)); }catch(_){ } }
  }
  return {values, sum, details};
}

</script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@2.1.0">
// === הוספת נקודות מהזיהוי לשחקן ===
function awardPointsFromDetection(playerIdx, points) {
  try {
    if (typeof points !== 'number' || !isFinite(points) || points <= 0) return;
    if (Array.isArray(window.players) && window.players[playerIdx]) {
      window.players[playerIdx].score = (window.players[playerIdx].score || 0) + points;
    }
    // עדכון UI אם יש
    let row = document.querySelectorAll('.board-row')[playerIdx];
    let scoreEl = row ? row.querySelector('.score') : null;
    if (scoreEl) {
      const newScore = window.players[playerIdx].score;
      scoreEl.textContent = newScore;
    }
    // הצגה בתחתית
    const lastDetLabel = document.getElementById('lastDetectLabel');
    if (lastDetLabel) {
      const pName = window.players[playerIdx]?.name || `שחקן ${playerIdx+1}`;
      lastDetLabel.textContent = `נוסף לשחקן “${pName}” ${points} נק׳ (סה״כ ${window.players[playerIdx].score})`;
    }
  } catch(err) {
    console.error("awardPointsFromDetection error", err);
  }
}


// === Multi‑tile helpers (non-destructive) ===
function __rk_toGray(r,g,b){ return (r*0.299 + g*0.587 + b*0.114) |0; }
function __rk_otsu(gray, w, h){
  const hist = new Array(256).fill(0); for(let i=0;i<gray.length;i++) hist[gray[i]]++;
  const total = w*h; let sum=0; for(let t=0;t<256;t++) sum += t*hist[t];
  let sumB=0, wB=0, wF=0, varMax=0, thr=0;
  for(let t=0;t<256;t++){ wB += hist[t]; if(wB===0) continue; wF = total - wB; if(wF===0) break;
    sumB += t*hist[t]; const mB = sumB / wB; const mF = (sum - sumB) / wF;
    const between = wB*wF*(mB-mF)*(mB-mF); if (between > varMax){ varMax = between; thr = t; } }
  return thr;
}
// returns {boxes:[{x,y,w,h}], ox, oy, nw, nh}
function __rk_segment(img, options){
  const cvs = document.createElement('canvas'), ctx = cvs.getContext('2d');
  const CW = 960, CH = 540; cvs.width=CW; cvs.height=CH;
  const scale = Math.min(CW/img.width, CH/img.height);
  const nw = Math.round(img.width*scale), nh = Math.round(img.height*scale);
  const ox = Math.round((CW - nw)/2), oy = Math.round((CH - nh)/2);
  ctx.clearRect(0,0,CW,CH); ctx.drawImage(img, ox, oy, nw, nh);

  const id = ctx.getImageData(ox, oy, nw, nh), data = id.data;
  const gray = new Uint8ClampedArray(nw*nh);
  for(let y=0;y<nh;y++){ for(let x=0;x<nw;x++){
    const i = (y*nw + x)*4; const r=data[i], g=data[i+1], b=data[i+2];
    gray[y*nw+x] = options.ignoreColor ? __rk_toGray(r,g,b) : Math.max(r,g,b);
  }};
  const thr = options.thr>0? options.thr : __rk_otsu(gray, nw, nh);
  const bin = new Uint8Array(nw*nh);
  for(let i=0;i<gray.length;i++) bin[i] = gray[i] > thr ? 1 : 0;

  const labels = new Int32Array(nw*nh).fill(-1);
  const boxes = []; const qx=[], qy=[]; let label=0;
  for(let y=0;y<nh;y++){ for(let x=0;x<nw;x++){
    const idx = y*nw + x; if(bin[idx]===0 || labels[idx]!==-1) continue;
    let minx=x, miny=y, maxx=x, maxy=y, area=0; qx.length=0; qy.length=0; qx.push(x); qy.push(y); labels[idx]=label;
    while(qx.length){ const cx=qx.pop(), cy=qy.pop(); const cidx=cy*nw+cx; area++;
      if(cx<minx) minx=cx; if(cy<miny) miny=cy; if(cx>maxx) maxx=cx; if(cy>maxy) maxy=cy;
      const nbs=[[1,0],[-1,0],[0,1],[0,-1]];
      for(const [dx,dy] of nbs){ const nx=cx+dx, ny=cy+dy; if(nx<0||ny<0||nx>=nw||ny>=nh) continue;
        const nidx=ny*nw+nx; if(bin[nidx]===1 && labels[nidx]===-1){ labels[nidx]=label; qx.push(nx); qy.push(ny); } }
    }
    const bw=maxx-minx+1, bh=maxy-miny+1; const aspect = Math.min(bw,bh)/Math.max(bw,bh);
    if(area>= (options.minArea||1600) && aspect>= (options.aspectMin||0.5) && aspect<= (options.aspectMax||1.0)){
      boxes.push({x:minx,y:miny,w:bw,h:bh,area,aspect});
    }
    label++;
  }}
  boxes.sort((a,b)=> a.y===b.y ? a.x-b.x : a.y-b.y);
  if(boxes.length>(options.maxCount||12)) boxes.length = (options.maxCount||12);
  return {boxes, ox, oy, nw, nh, CW, CH};
}
// classify crops and return {values:[...], sum, details:[{n,conf}]}
async function __rk_classifyCropsFromSeg(seg){
  await ensureModels?.();
  const off = document.createElement('canvas'); off.width=112; off.height=112; const oc = off.getContext('2d');
  let sum=0, values=[], details=[];
  for(let i=0;i<seg.boxes.length;i++){
    const b = seg.boxes[i]; const pad = Math.floor(Math.min(b.w,b.h)*0.08);
    // draw original image (held in last image loaded in previous step): we don't have it here; we'll reconstruct from stage if exists
    const stage = document.getElementById('stage');
    if(!stage){ continue; }
    oc.clearRect(0,0,112,112);
    oc.drawImage(stage, seg.ox + b.x - pad, seg.oy + b.y - pad, b.w + pad*2, b.h + pad*2, 0,0,112,112);
    try{
      const feat = net.infer(off, 'conv_preds');
      const res = await classifier.predictClass(feat, 3);
      if(res && res.label!=null){
        const v = parseInt(res.label,10);
        const cfs = Object.values(res.confidences||{}); const conf = Math.round(Math.max(...cfs)*100);
        if(Number.isFinite(v)){ values.push(v); sum += v; details.push({n:v, conf}); }
      }
    }catch(err){ try{ log && log('multi: classify error '+(err?.message||err)); }catch(_){ } }
  }
  return {values, sum, details};
}

</script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/knn-classifier@1.2.2">
// === הוספת נקודות מהזיהוי לשחקן ===
function awardPointsFromDetection(playerIdx, points) {
  try {
    if (typeof points !== 'number' || !isFinite(points) || points <= 0) return;
    if (Array.isArray(window.players) && window.players[playerIdx]) {
      window.players[playerIdx].score = (window.players[playerIdx].score || 0) + points;
    }
    // עדכון UI אם יש
    let row = document.querySelectorAll('.board-row')[playerIdx];
    let scoreEl = row ? row.querySelector('.score') : null;
    if (scoreEl) {
      const newScore = window.players[playerIdx].score;
      scoreEl.textContent = newScore;
    }
    // הצגה בתחתית
    const lastDetLabel = document.getElementById('lastDetectLabel');
    if (lastDetLabel) {
      const pName = window.players[playerIdx]?.name || `שחקן ${playerIdx+1}`;
      lastDetLabel.textContent = `נוסף לשחקן “${pName}” ${points} נק׳ (סה״כ ${window.players[playerIdx].score})`;
    }
  } catch(err) {
    console.error("awardPointsFromDetection error", err);
  }
}


// === Multi‑tile helpers (non-destructive) ===
function __rk_toGray(r,g,b){ return (r*0.299 + g*0.587 + b*0.114) |0; }
function __rk_otsu(gray, w, h){
  const hist = new Array(256).fill(0); for(let i=0;i<gray.length;i++) hist[gray[i]]++;
  const total = w*h; let sum=0; for(let t=0;t<256;t++) sum += t*hist[t];
  let sumB=0, wB=0, wF=0, varMax=0, thr=0;
  for(let t=0;t<256;t++){ wB += hist[t]; if(wB===0) continue; wF = total - wB; if(wF===0) break;
    sumB += t*hist[t]; const mB = sumB / wB; const mF = (sum - sumB) / wF;
    const between = wB*wF*(mB-mF)*(mB-mF); if (between > varMax){ varMax = between; thr = t; } }
  return thr;
}
// returns {boxes:[{x,y,w,h}], ox, oy, nw, nh}
function __rk_segment(img, options){
  const cvs = document.createElement('canvas'), ctx = cvs.getContext('2d');
  const CW = 960, CH = 540; cvs.width=CW; cvs.height=CH;
  const scale = Math.min(CW/img.width, CH/img.height);
  const nw = Math.round(img.width*scale), nh = Math.round(img.height*scale);
  const ox = Math.round((CW - nw)/2), oy = Math.round((CH - nh)/2);
  ctx.clearRect(0,0,CW,CH); ctx.drawImage(img, ox, oy, nw, nh);

  const id = ctx.getImageData(ox, oy, nw, nh), data = id.data;
  const gray = new Uint8ClampedArray(nw*nh);
  for(let y=0;y<nh;y++){ for(let x=0;x<nw;x++){
    const i = (y*nw + x)*4; const r=data[i], g=data[i+1], b=data[i+2];
    gray[y*nw+x] = options.ignoreColor ? __rk_toGray(r,g,b) : Math.max(r,g,b);
  }};
  const thr = options.thr>0? options.thr : __rk_otsu(gray, nw, nh);
  const bin = new Uint8Array(nw*nh);
  for(let i=0;i<gray.length;i++) bin[i] = gray[i] > thr ? 1 : 0;

  const labels = new Int32Array(nw*nh).fill(-1);
  const boxes = []; const qx=[], qy=[]; let label=0;
  for(let y=0;y<nh;y++){ for(let x=0;x<nw;x++){
    const idx = y*nw + x; if(bin[idx]===0 || labels[idx]!==-1) continue;
    let minx=x, miny=y, maxx=x, maxy=y, area=0; qx.length=0; qy.length=0; qx.push(x); qy.push(y); labels[idx]=label;
    while(qx.length){ const cx=qx.pop(), cy=qy.pop(); const cidx=cy*nw+cx; area++;
      if(cx<minx) minx=cx; if(cy<miny) miny=cy; if(cx>maxx) maxx=cx; if(cy>maxy) maxy=cy;
      const nbs=[[1,0],[-1,0],[0,1],[0,-1]];
      for(const [dx,dy] of nbs){ const nx=cx+dx, ny=cy+dy; if(nx<0||ny<0||nx>=nw||ny>=nh) continue;
        const nidx=ny*nw+nx; if(bin[nidx]===1 && labels[nidx]===-1){ labels[nidx]=label; qx.push(nx); qy.push(ny); } }
    }
    const bw=maxx-minx+1, bh=maxy-miny+1; const aspect = Math.min(bw,bh)/Math.max(bw,bh);
    if(area>= (options.minArea||1600) && aspect>= (options.aspectMin||0.5) && aspect<= (options.aspectMax||1.0)){
      boxes.push({x:minx,y:miny,w:bw,h:bh,area,aspect});
    }
    label++;
  }}
  boxes.sort((a,b)=> a.y===b.y ? a.x-b.x : a.y-b.y);
  if(boxes.length>(options.maxCount||12)) boxes.length = (options.maxCount||12);
  return {boxes, ox, oy, nw, nh, CW, CH};
}
// classify crops and return {values:[...], sum, details:[{n,conf}]}
async function __rk_classifyCropsFromSeg(seg){
  await ensureModels?.();
  const off = document.createElement('canvas'); off.width=112; off.height=112; const oc = off.getContext('2d');
  let sum=0, values=[], details=[];
  for(let i=0;i<seg.boxes.length;i++){
    const b = seg.boxes[i]; const pad = Math.floor(Math.min(b.w,b.h)*0.08);
    // draw original image (held in last image loaded in previous step): we don't have it here; we'll reconstruct from stage if exists
    const stage = document.getElementById('stage');
    if(!stage){ continue; }
    oc.clearRect(0,0,112,112);
    oc.drawImage(stage, seg.ox + b.x - pad, seg.oy + b.y - pad, b.w + pad*2, b.h + pad*2, 0,0,112,112);
    try{
      const feat = net.infer(off, 'conv_preds');
      const res = await classifier.predictClass(feat, 3);
      if(res && res.label!=null){
        const v = parseInt(res.label,10);
        const cfs = Object.values(res.confidences||{}); const conf = Math.round(Math.max(...cfs)*100);
        if(Number.isFinite(v)){ values.push(v); sum += v; details.push({n:v, conf}); }
      }
    }catch(err){ try{ log && log('multi: classify error '+(err?.message||err)); }catch(_){ } }
  }
  return {values, sum, details};
}

</script>
<script>
const VERSION = 'v5.13-ml';
const $$ = sel => document.querySelector(sel);
const on = (el,ev,fn) => el.addEventListener(ev,fn);
const log = msg => { const d=$$('#debug'); d.textContent += (d.textContent? '\\n':'') + msg; d.scrollTop=d.scrollHeight; };

// ====== מצב אפליקציה בסיסי (שמות + ניקוד) ======
let players = []; // {name, score}
function loadNames(){
  const saved = JSON.parse(localStorage.getItem('rk_players') || '[]');
  for(let i=0;i<4;i++){
    const val = saved[i]?.name || '';
    $$('#p'+(i+1)).value = val;
  }
}
function saveNames(){
  players = [];
  for(let i=0;i<4;i++){
    const name = ($$('#p'+(i+1)).value || '').trim() || ('שחקן ' + (i+1));
    players.push({name, score:0});
  }
  localStorage.setItem('rk_players', JSON.stringify(players));
}
function renderBoard(){
  const holder = $$('#boardRows'); holder.innerHTML='';
  players.forEach((p,idx)=>{
    const row=document.createElement('div'); row.className='row';
    row.innerHTML = `
      <div>${idx+1}</div>
      <div>${p.name}</div>
      <div><span id="sc_${idx}">${p.score}</span></div>
      <div class="flex">
        <button class="btn good" data-d="+10">+10</button>
        <button class="btn bad" data-d="-10">-10</button>
        <input class="manual" type="number" placeholder="ערך" style="width:92px">
        <button class="btn acc" data-d="manual">הוסף</button>
        <label class="btn cam nowrap">📷
          <input class="snap" type="file" accept="image/*" capture="environment" hidden>
        </label>
      </div>`;
    holder.appendChild(row);
    // אירועים
    const [bPlus,bMinus,inputManual,bManual,labelCam] = row.querySelectorAll('button,input,label');
    bPlus.onclick=()=>bump(idx, +10);
    bMinus.onclick=()=>bump(idx, -10);
    bManual.onclick=()=>{
      const v = parseInt(inputManual.value||'0',10);
      if(!isNaN(v)) bump(idx, v);
    };
    labelCam.querySelector('input.snap').onchange = async (e)=>{
      // תמונת שחקן -> כרגע רק מציגה חיווי; (המודל נשאר מודול אימון למטה).
      if(e.target.files?.length){
        log(`🎞️ נקלט צילום לשחקן ${idx+1} (${players[idx].name}).`);
        
// show textual indication only

showLastDetect(idx, e.target.files[0]);
try{
  await ensureModels?.();
  const {img} = await imgToTensor(e.target.files[0]);

  // Draw to a known canvas 'stage' so the segmentation cropper can reuse pixels
  (function(){
    let stage = document.getElementById('stage');
    if(!stage){ stage = document.createElement('canvas'); stage.id='stage'; stage.width=960; stage.height=540; stage.style.display='none'; document.body.appendChild(stage); }
    const ctx = stage.getContext('2d');
    const scale = Math.min(stage.width/img.width, stage.height/img.height);
    const nw = Math.round(img.width*scale), nh = Math.round(img.height*scale);
    const ox = Math.round((stage.width - nw)/2), oy = Math.round((stage.height - nh)/2);
    ctx.clearRect(0,0,stage.width, stage.height);
    ctx.drawImage(img, ox, oy, nw, nh);
  })();

  // Segment multiple tiles and classify
  const seg = __rk_segment(img, {ignoreColor:true, thr:0, minArea:1200, maxCount:20, aspectMin:0.5, aspectMax:1.2});
  const result = await __rk_classifyCropsFromSeg(seg);

  if(result && result.values && result.values.length){
    const sum = result.sum;
    // fill ONLY the current row's 'manual' input
    try{
      const input = row.querySelector('input.manual') || row.querySelector('input[type="number"]');
      if(input){ input.value = sum; }
    }catch(_){}

    // textual indication
    const lbl = document.getElementById('lastDetectLabel');
    if(lbl){
      lbl.textContent = `זיהוי מרובה: שחקן ${idx+1} • ${players[idx]?.name||''} — [${result.values.join('+')}] = ${sum}`;
    }
    // stop here: let the user click "הוסף" ידנית; do NOT auto‑award
    // If you later want auto-sum award: call awardPointsFromDetection(idx, sum);
  } else {
    // fallback to single‑tile pipeline you already had below
 (אם ביקשת בעבר)
  if(typeof detected !== 'undefined' && detected){
    if(typeof awardPointsFromDetection === 'function'){
      awardPointsFromDetection(idx, detected);
    }
  }
}catch(_){ /* keep silent */ }
if(typeof detectedValue!=='undefined'){ awardPointsFromDetection(idx, detectedValue); }
      }
    }
  });
}
function bump(index, delta){
  players[index].score += delta;
  $$('#sc_'+index).textContent = players[index].score;
  localStorage.setItem('rk_players', JSON.stringify(players));
}


// == זיהוי אחרון – תצוגה ==
function showLastDetect(playerIndex, file){
  const url = URL.createObjectURL(file);
  const img = null;
  const label = $$('#lastDetectLabel');
  // no image preview
  if(label){ label.textContent = `זיהוי אחרון: שחקן ${playerIndex+1} • ${players[playerIndex].name}`; }
}

// ====== אתחול שמות וניקוד ======
loadNames();
saveNames();
renderBoard();

on($$('#btnSaveNames'),'click',()=>{ saveNames(); renderBoard(); });
on($$('#btnStart'),'click',()=>{ saveNames(); renderBoard(); });
on($$('#btnResetScores'),'click',()=>{
  players.forEach(p=>p.score=0); renderBoard();
  localStorage.setItem('rk_players', JSON.stringify(players));
});

// ====== מודול אימון (MobileNet+KNN) – כמו בגרסה הבסיסית, ללא שינוי מהותי ======
let net, classifier;
let totalExamples = 0;

// הכרחת CPU – לביציבות במובייל
(async ()=>{
  try{
    await tf.setBackend('cpu');
  }catch(e){}
  $$('#tfBadge').textContent = 'TF: ' + tf.getBackend();
})();

async function ensureModels(){
  if(net && classifier) return;
  log('loading mobilenet/knn...');
  classifier = knnClassifier.create();
  net = await mobilenet.load();
  log('models loaded');
  $$('#modelBadge').textContent = 'model: ready';
}

function imgToTensor(file){
  return new Promise((resolve,reject)=>{
    const img = new Image();
    img.onload=()=>{
      const t = tf.tidy(()=>tf.browser.fromPixels(img).toFloat());
      resolve({img, tensor:t});
    };
    img.onerror=reject;
    img.src = URL.createObjectURL(file);
  });
}

async function addExample(file, classId){
  await ensureModels();
  const {img, tensor} = await imgToTensor(file);
  const activation = net.infer(img, true);
  classifier.addExample(activation, classId);
  activation.dispose(); tensor.dispose();
  totalExamples++;
  $$('#examplesBadge').textContent = 'דוגמאות: ' + totalExamples;
}

async function handleFiles(files, classId){
  if(!files || files.length===0) return;
  for(const f of files){
    await addExample(f, classId);
  }
  $$('#statusSpan').textContent = `נוספו ${files.length} דוגמאות למחלקה ${classId}`;
}

on($$('#filePick'),'change',e=>{
  const classId = parseInt($$('#classId').value,10)||1;
  handleFiles(e.target.files, classId);
});
on($$('#filePickCam'),'change',e=>{
  const classId = parseInt($$('#classId').value,10)||1;
  handleFiles(e.target.files, classId);
});

// ניהול מודל (ייצוא/ייבוא/שמירה מקומית)
function exportJSON(){
  if(!classifier){ alert('אין מודל טעון'); return; }
  const dataset = classifier.getClassifierDataset();
  const dataObj = {};
  Object.keys(dataset).forEach(key=>{
    const data = dataset[key].dataSync();
    dataObj[key] = Array.from(data);
  });
  const json = JSON.stringify({dataObj, shape: dataset[Object.keys(dataset)[0]]?.shape || []});
  const blob = new Blob([json], {type:'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'rk_model.json';
  a.click();
}
on($$('#btnExportJSON'),'click', exportJSON);

on($$('#jsonIn'),'change',async e=>{
  const file = e.target.files?.[0]; if(!file) return;
  const text = await file.text();
  restoreFromJSON(text,true);
});

function restoreFromJSON(text, show=true){
  try{
    const obj = JSON.parse(text);
    classifier = knnClassifier.create();
    const dataset = {};
    Object.keys(obj.dataObj).forEach(key=>{
      const tensor = tf.tensor(obj.dataObj[key], obj.shape);
      dataset[key] = tensor;
    });
    classifier.setClassifierDataset(dataset);
    const vectors = Object.values(dataset).reduce((a,t)=>a+(t.shape?.[0]||0),0);
    totalExamples = vectors;
    $$('#examplesBadge').textContent = 'דוגמאות: ' + totalExamples;
    if(show) log('✅ model restored from JSON');
    $$('#modelBadge').textContent = 'model: restored';
  }catch(err){
    log('ERR restore: '+err.message);
    alert('ייבוא נכשל');
  }
}

// שמירה/שחזור ל-localStorage
on($$('#btnSaveModel'),'click',()=>{
  if(!classifier){ alert('אין מודל'); return; }
  const dataset = classifier.getClassifierDataset();
  const dataObj = {};
  Object.keys(dataset).forEach(key=> dataObj[key] = Array.from(dataset[key].dataSync()));
  const payload = JSON.stringify({dataObj, shape: dataset[Object.keys(dataset)[0]]?.shape || []});
  localStorage.setItem('rk_model', payload);
  const bytes = new Blob([payload]).size;
  log(`💾 נשמר מקומית • ~${(bytes/1024).toFixed(1)} KB`);
  $$('#modelBadge').textContent = 'model: saved';
});

on($$('#btnLoadModel'),'click',()=>{
  const payload = localStorage.getItem('rk_model');
  if(!payload){ alert('לא נמצא מודל'); return; }
  restoreFromJSON(payload,false);
  const bytes = new Blob([payload]).size;
  log(`📦 שוחזר מקומית • ${(bytes/1024).toFixed(1)} KB`);
  $$('#modelBadge').textContent = 'model: restored';
});

on($$('#btnNukeExamples'),'click',()=>{
  classifier = knnClassifier.create();
  totalExamples = 0;
  $$('#examplesBadge').textContent = 'דוגמאות: —';
  log('🧹 נוקה.');
});

on($$('#btnInitModel'),'click',()=>{
  // Initialize model: wipe in-memory KNN and clear saved model
  classifier = knnClassifier.create();
  totalExamples = 0;
  $$('#examplesBadge').textContent = 'דוגמאות: —';
  localStorage.removeItem('rk_model'); // forget saved model
  $$('#modelBadge').textContent = 'model: initialized';
  log('♻️ אתחול מודל: הדאטה נוקה וה־localStorage הוסר');
});

// אתחול ראשוני
(async function init(){
  $$('#verBadge').textContent = VERSION;
  try{
    await ensureModels();
    $$('#modelBadge').textContent = 'model: ready';
    // נסיון לשחזר אוטומטית
    const payload = localStorage.getItem('rk_model');
    if(payload){ restoreFromJSON(payload,false); log('auto-restore: ok'); }
  }catch(err){
    log('init error: '+err.message);
  }
})();

// === הוספת נקודות מהזיהוי לשחקן ===
function awardPointsFromDetection(playerIdx, points) {
  try {
    if (typeof points !== 'number' || !isFinite(points) || points <= 0) return;
    if (Array.isArray(window.players) && window.players[playerIdx]) {
      window.players[playerIdx].score = (window.players[playerIdx].score || 0) + points;
    }
    // עדכון UI אם יש
    let row = document.querySelectorAll('.board-row')[playerIdx];
    let scoreEl = row ? row.querySelector('.score') : null;
    if (scoreEl) {
      const newScore = window.players[playerIdx].score;
      scoreEl.textContent = newScore;
    }
    // הצגה בתחתית
    const lastDetLabel = document.getElementById('lastDetectLabel');
    if (lastDetLabel) {
      const pName = window.players[playerIdx]?.name || `שחקן ${playerIdx+1}`;
      lastDetLabel.textContent = `נוסף לשחקן “${pName}” ${points} נק׳ (סה״כ ${window.players[playerIdx].score})`;
    }
  } catch(err) {
    console.error("awardPointsFromDetection error", err);
  }
}


// === Multi‑tile helpers (non-destructive) ===
function __rk_toGray(r,g,b){ return (r*0.299 + g*0.587 + b*0.114) |0; }
function __rk_otsu(gray, w, h){
  const hist = new Array(256).fill(0); for(let i=0;i<gray.length;i++) hist[gray[i]]++;
  const total = w*h; let sum=0; for(let t=0;t<256;t++) sum += t*hist[t];
  let sumB=0, wB=0, wF=0, varMax=0, thr=0;
  for(let t=0;t<256;t++){ wB += hist[t]; if(wB===0) continue; wF = total - wB; if(wF===0) break;
    sumB += t*hist[t]; const mB = sumB / wB; const mF = (sum - sumB) / wF;
    const between = wB*wF*(mB-mF)*(mB-mF); if (between > varMax){ varMax = between; thr = t; } }
  return thr;
}
// returns {boxes:[{x,y,w,h}], ox, oy, nw, nh}
function __rk_segment(img, options){
  const cvs = document.createElement('canvas'), ctx = cvs.getContext('2d');
  const CW = 960, CH = 540; cvs.width=CW; cvs.height=CH;
  const scale = Math.min(CW/img.width, CH/img.height);
  const nw = Math.round(img.width*scale), nh = Math.round(img.height*scale);
  const ox = Math.round((CW - nw)/2), oy = Math.round((CH - nh)/2);
  ctx.clearRect(0,0,CW,CH); ctx.drawImage(img, ox, oy, nw, nh);

  const id = ctx.getImageData(ox, oy, nw, nh), data = id.data;
  const gray = new Uint8ClampedArray(nw*nh);
  for(let y=0;y<nh;y++){ for(let x=0;x<nw;x++){
    const i = (y*nw + x)*4; const r=data[i], g=data[i+1], b=data[i+2];
    gray[y*nw+x] = options.ignoreColor ? __rk_toGray(r,g,b) : Math.max(r,g,b);
  }};
  const thr = options.thr>0? options.thr : __rk_otsu(gray, nw, nh);
  const bin = new Uint8Array(nw*nh);
  for(let i=0;i<gray.length;i++) bin[i] = gray[i] > thr ? 1 : 0;

  const labels = new Int32Array(nw*nh).fill(-1);
  const boxes = []; const qx=[], qy=[]; let label=0;
  for(let y=0;y<nh;y++){ for(let x=0;x<nw;x++){
    const idx = y*nw + x; if(bin[idx]===0 || labels[idx]!==-1) continue;
    let minx=x, miny=y, maxx=x, maxy=y, area=0; qx.length=0; qy.length=0; qx.push(x); qy.push(y); labels[idx]=label;
    while(qx.length){ const cx=qx.pop(), cy=qy.pop(); const cidx=cy*nw+cx; area++;
      if(cx<minx) minx=cx; if(cy<miny) miny=cy; if(cx>maxx) maxx=cx; if(cy>maxy) maxy=cy;
      const nbs=[[1,0],[-1,0],[0,1],[0,-1]];
      for(const [dx,dy] of nbs){ const nx=cx+dx, ny=cy+dy; if(nx<0||ny<0||nx>=nw||ny>=nh) continue;
        const nidx=ny*nw+nx; if(bin[nidx]===1 && labels[nidx]===-1){ labels[nidx]=label; qx.push(nx); qy.push(ny); } }
    }
    const bw=maxx-minx+1, bh=maxy-miny+1; const aspect = Math.min(bw,bh)/Math.max(bw,bh);
    if(area>= (options.minArea||1600) && aspect>= (options.aspectMin||0.5) && aspect<= (options.aspectMax||1.0)){
      boxes.push({x:minx,y:miny,w:bw,h:bh,area,aspect});
    }
    label++;
  }}
  boxes.sort((a,b)=> a.y===b.y ? a.x-b.x : a.y-b.y);
  if(boxes.length>(options.maxCount||12)) boxes.length = (options.maxCount||12);
  return {boxes, ox, oy, nw, nh, CW, CH};
}
// classify crops and return {values:[...], sum, details:[{n,conf}]}
async function __rk_classifyCropsFromSeg(seg){
  await ensureModels?.();
  const off = document.createElement('canvas'); off.width=112; off.height=112; const oc = off.getContext('2d');
  let sum=0, values=[], details=[];
  for(let i=0;i<seg.boxes.length;i++){
    const b = seg.boxes[i]; const pad = Math.floor(Math.min(b.w,b.h)*0.08);
    // draw original image (held in last image loaded in previous step): we don't have it here; we'll reconstruct from stage if exists
    const stage = document.getElementById('stage');
    if(!stage){ continue; }
    oc.clearRect(0,0,112,112);
    oc.drawImage(stage, seg.ox + b.x - pad, seg.oy + b.y - pad, b.w + pad*2, b.h + pad*2, 0,0,112,112);
    try{
      const feat = net.infer(off, 'conv_preds');
      const res = await classifier.predictClass(feat, 3);
      if(res && res.label!=null){
        const v = parseInt(res.label,10);
        const cfs = Object.values(res.confidences||{}); const conf = Math.round(Math.max(...cfs)*100);
        if(Number.isFinite(v)){ values.push(v); sum += v; details.push({n:v, conf}); }
      }
    }catch(err){ try{ log && log('multi: classify error '+(err?.message||err)); }catch(_){ } }
  }
  return {values, sum, details};
}

</script>

<!-- v5.13-ml minimal patch: fill detected value into the "ערך" input next to the correct player -->
<script>
(function(){
  // Helper: safe debug log
  function dlog(msg){
    try {
      var dbg = document.getElementById('debug') || document.querySelector('.debug, #Debug');
      if (!dbg) return;
      var line = (dbg.value ?? dbg.textContent ?? '');
      var add = String(msg);
      if ('value' in dbg) dbg.value = (line ? line + '\n' : '') + add;
      else dbg.textContent = (line ? line + '\n' : '') + add;
      dbg.scrollTop = dbg.scrollHeight;
    } catch(_) {}
  }

  // Try to find the UI row for a given player index
  function getPlayerRow(idx){
    // 1) Preferred: data attribute
    var row = document.querySelector('[data-player-index="'+idx+'"]');
    if (row) return row;
    // 2) Common containers
    var candidates = document.querySelectorAll('#players > * , .boardGrid > * , .board-row, .leaderboard-row, .player-row');
    if (candidates && candidates.length){
      // assume 4 columns per row -> try grouping by 4 (index*4 … index*4+3)
      if (candidates.length >= (idx*4+1)) {
        var groupStart = idx*4;
        // wrap a div to represent the row if needed
        var wrapper = document.createElement('div');
        for (var i=groupStart;i<Math.min(groupStart+4, candidates.length);i++){
          wrapper.appendChild(candidates[i].cloneNode(true));
        }
        return wrapper; // fallback (will still allow finding an input inside if structure matches)
      }
    }
    // 3) As a last resort, take nth occurrence of a row-like block
    var rows = document.querySelectorAll('.row, .grid, .line');
    if (rows && rows[idx]) return rows[idx];
    return null;
  }

  
  function fillDetectedValue(idx, val){
    try{
      if (!Number.isFinite(val)) return;
      // strictly target the player's own row by data attribute
      var row = document.querySelector('[data-player-index="'+idx+'"]');
      if (!row) return;
      var input = row.querySelector('input.manual') ||
                  row.querySelector('input[type="number"]') ||
                  row.querySelector('input[placeholder="ערך"]') ||
                  row.querySelector('input[name="value"]') ||
                  row.querySelector('input[data-role="value"]');
      if (input){
        input.value = val;
        dlog('fill(row-only): idx='+idx+' val='+val);
      } else {
        dlog('fill(row-only): input not found in row for idx='+idx);
      }
    }catch(err){
      dlog('fill error: '+(err && err.message || err));
    }
  }
else {
        dlog('fill: idx='+idx+' val='+val+' -> input not found');
      }
    }catch(err){
      dlog('fill error: '+(err && err.message || err));
    }
  }

  // If awardPointsFromDetection exists, wrap it to ALSO fill the input (without changing its behavior).
  if (typeof window.awardPointsFromDetection === 'function'){
    var __origAward = window.awardPointsFromDetection;
    window.awardPointsFromDetection = function(idx, points){
      // Fill the number box for manual confirmation if desired
      try { fillDetectedValue(idx, Number(points)); } catch(_){}
      // Preserve original behavior exactly
      return __origAward.apply(this, arguments);
    };
    dlog('patch v5.10: wrapped awardPointsFromDetection to fill input');
  } else {
    // Expose a helper for your detection code to call explicitly:
    window.__afterDetected_fillValue_v510 = fillDetectedValue;
    dlog('patch v5.10: expose __afterDetected_fillValue_v510(idx,val)');
  }
})();

// === Multi‑tile helpers (non-destructive) ===
function __rk_toGray(r,g,b){ return (r*0.299 + g*0.587 + b*0.114) |0; }
function __rk_otsu(gray, w, h){
  const hist = new Array(256).fill(0); for(let i=0;i<gray.length;i++) hist[gray[i]]++;
  const total = w*h; let sum=0; for(let t=0;t<256;t++) sum += t*hist[t];
  let sumB=0, wB=0, wF=0, varMax=0, thr=0;
  for(let t=0;t<256;t++){ wB += hist[t]; if(wB===0) continue; wF = total - wB; if(wF===0) break;
    sumB += t*hist[t]; const mB = sumB / wB; const mF = (sum - sumB) / wF;
    const between = wB*wF*(mB-mF)*(mB-mF); if (between > varMax){ varMax = between; thr = t; } }
  return thr;
}
// returns {boxes:[{x,y,w,h}], ox, oy, nw, nh}
function __rk_segment(img, options){
  const cvs = document.createElement('canvas'), ctx = cvs.getContext('2d');
  const CW = 960, CH = 540; cvs.width=CW; cvs.height=CH;
  const scale = Math.min(CW/img.width, CH/img.height);
  const nw = Math.round(img.width*scale), nh = Math.round(img.height*scale);
  const ox = Math.round((CW - nw)/2), oy = Math.round((CH - nh)/2);
  ctx.clearRect(0,0,CW,CH); ctx.drawImage(img, ox, oy, nw, nh);

  const id = ctx.getImageData(ox, oy, nw, nh), data = id.data;
  const gray = new Uint8ClampedArray(nw*nh);
  for(let y=0;y<nh;y++){ for(let x=0;x<nw;x++){
    const i = (y*nw + x)*4; const r=data[i], g=data[i+1], b=data[i+2];
    gray[y*nw+x] = options.ignoreColor ? __rk_toGray(r,g,b) : Math.max(r,g,b);
  }};
  const thr = options.thr>0? options.thr : __rk_otsu(gray, nw, nh);
  const bin = new Uint8Array(nw*nh);
  for(let i=0;i<gray.length;i++) bin[i] = gray[i] > thr ? 1 : 0;

  const labels = new Int32Array(nw*nh).fill(-1);
  const boxes = []; const qx=[], qy=[]; let label=0;
  for(let y=0;y<nh;y++){ for(let x=0;x<nw;x++){
    const idx = y*nw + x; if(bin[idx]===0 || labels[idx]!==-1) continue;
    let minx=x, miny=y, maxx=x, maxy=y, area=0; qx.length=0; qy.length=0; qx.push(x); qy.push(y); labels[idx]=label;
    while(qx.length){ const cx=qx.pop(), cy=qy.pop(); const cidx=cy*nw+cx; area++;
      if(cx<minx) minx=cx; if(cy<miny) miny=cy; if(cx>maxx) maxx=cx; if(cy>maxy) maxy=cy;
      const nbs=[[1,0],[-1,0],[0,1],[0,-1]];
      for(const [dx,dy] of nbs){ const nx=cx+dx, ny=cy+dy; if(nx<0||ny<0||nx>=nw||ny>=nh) continue;
        const nidx=ny*nw+nx; if(bin[nidx]===1 && labels[nidx]===-1){ labels[nidx]=label; qx.push(nx); qy.push(ny); } }
    }
    const bw=maxx-minx+1, bh=maxy-miny+1; const aspect = Math.min(bw,bh)/Math.max(bw,bh);
    if(area>= (options.minArea||1600) && aspect>= (options.aspectMin||0.5) && aspect<= (options.aspectMax||1.0)){
      boxes.push({x:minx,y:miny,w:bw,h:bh,area,aspect});
    }
    label++;
  }}
  boxes.sort((a,b)=> a.y===b.y ? a.x-b.x : a.y-b.y);
  if(boxes.length>(options.maxCount||12)) boxes.length = (options.maxCount||12);
  return {boxes, ox, oy, nw, nh, CW, CH};
}
// classify crops and return {values:[...], sum, details:[{n,conf}]}
async function __rk_classifyCropsFromSeg(seg){
  await ensureModels?.();
  const off = document.createElement('canvas'); off.width=112; off.height=112; const oc = off.getContext('2d');
  let sum=0, values=[], details=[];
  for(let i=0;i<seg.boxes.length;i++){
    const b = seg.boxes[i]; const pad = Math.floor(Math.min(b.w,b.h)*0.08);
    // draw original image (held in last image loaded in previous step): we don't have it here; we'll reconstruct from stage if exists
    const stage = document.getElementById('stage');
    if(!stage){ continue; }
    oc.clearRect(0,0,112,112);
    oc.drawImage(stage, seg.ox + b.x - pad, seg.oy + b.y - pad, b.w + pad*2, b.h + pad*2, 0,0,112,112);
    try{
      const feat = net.infer(off, 'conv_preds');
      const res = await classifier.predictClass(feat, 3);
      if(res && res.label!=null){
        const v = parseInt(res.label,10);
        const cfs = Object.values(res.confidences||{}); const conf = Math.round(Math.max(...cfs)*100);
        if(Number.isFinite(v)){ values.push(v); sum += v; details.push({n:v, conf}); }
      }
    }catch(err){ try{ log && log('multi: classify error '+(err?.message||err)); }catch(_){ } }
  }
  return {values, sum, details};
}

</script>

</body>
</html>
