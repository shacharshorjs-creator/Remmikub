<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>×¨××™×§×•×‘ â€“ ××©×—×§ + ××™××•×Ÿ (v2.66-ml)</title>
<link rel="preconnect" href="https://cdn.jsdelivr.net">
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@2.1.0"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/knn-classifier@1.2.2"></script>
<style>
  :root{
    --bg:#0e1220;--panel:#121a2e;--card:#141d33;--ink:#eaf1ff;--muted:#a2b3cc;--line:rgba(255,255,255,.12);
    --accent:#8be9fd;--good:#02c39a;--bad:#e76f51;--btn:#1f2a48;--btn2:#23345b;
  }
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.45 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Arial}
  .appbar{position:sticky;top:0;background:#0b1222;z-index:30;border-bottom:1px solid var(--line)}
  .wrap{width:min(1000px,95vw);margin:0 auto;padding:14px}
  .badges > *{display:inline-block;margin-inline-start:8px;background:#0a1a2f;border:1px solid #223b5c;padding:6px 10px;border-radius:999px;font-size:12px}
  .grid{display:grid;grid-template-columns:1fr;gap:14px}
  @media (min-width:920px){.grid{grid-template-columns:1fr 1fr;}}
  .card{background:var(--card);border:1px solid var(--line);border-radius:16px;padding:14px}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .btn{background:var(--btn);color:#fff;border:none;border-radius:12px;padding:8px 12px;cursor:pointer;opacity:.95}
  .btn.secondary{background:var(--btn2)}
  .btn.good{background:#114a3d;border:1px solid #1d7d66}
  .btn.bad{background:#3a1c1c;border:1px solid #5a2b2b}
  .btn:disabled{opacity:.5;cursor:not-allowed}
  input[type=text]{background:#0f162a;border:1px solid var(--line);color:var(--ink);padding:8px 10px;border-radius:10px}
  table{width:100%;border-collapse:collapse}
  th,td{border-bottom:1px solid var(--line);padding:10px 6px;text-align:center}
  .pill{display:inline-block;padding:4px 8px;border:1px solid var(--line);border-radius:999px;background:#0b1428;font-size:12px}
  .tiny{font-size:12px;color:var(--muted)}
  .drop{position:relative;border:2px dashed #34507a;border-radius:16px;padding:18px;text-align:center;background:#0d162b;user-select:none;overflow:hidden}
  .drop.drag{background:#0f1c36;border-color:#5984d6}
  .drop input[type=file]{position:absolute;inset:0;opacity:0;cursor:pointer}
  .thumbs{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .thumbs img{width:72px;height:72px;object-fit:cover;border-radius:10px;border:1px solid #2b3f63}
  pre{white-space:pre-wrap;background:#0a1020;border:1px solid var(--line);padding:10px;border-radius:12px;max-height:220px;overflow:auto}
  .tag{display:inline-block;background:#0a1a2f;border:1px solid #2b3d5e;border-radius:8px;padding:2px 6px;margin-inline-start:6px;font-size:12px}
</style>
</head>
<body>
<header class="appbar">
  <div class="wrap row" style="justify-content:space-between">
    <div class="badges">
      <span class="tag">×¨××™×§×•×‘ â€“ ××©×—×§ + ××™××•×Ÿ</span>
      <span id="ver" class="tag">v2.66-ml</span>
      <span id="tfBadge" class="tag">TF: initâ€¦</span>
      <span id="mdlBadge" class="tag">model: loadingâ€¦</span>
    </div>
    <div class="badges"><span id="counts" class="tag">×“×•×’×××•×ª: â€”</span></div>
  </div>

<span id="modelBadge" style="margin-inline-start:8px;padding:4px 8px;border-radius:12px;background:#24324d;color:#cfe3ff;font-size:.85rem;display:inline-block">model: â€”</span>
</header>

<main class="wrap grid">
  <!-- GAME SIDE -->
  <section class="card" id="gameSetup">
    <h3>×‘×—×™×¨×ª ××©×ª×ª×¤×™× (×¢×“ 4)</h3>
    <div class="row" style="margin-bottom:10px">
      <input id="p1" type="text" placeholder="×©×—×§×Ÿ/×™×ª 1">
      <input id="p2" type="text" placeholder="×©×—×§×Ÿ/×™×ª 2">
      <input id="p3" type="text" placeholder="××•×¤×¦×™×•× ×œ×™">
      <input id="p4" type="text" placeholder="××•×¤×¦×™×•× ×œ×™">
      <button class="btn good" id="btnStart">×”×ª×—×œ ××©×—×§</button>
    </div>
    <div class="tiny">×©××•×ª ×¨×™×§×™× ×™×™×“×œ×’×•.</div>
  </section>

  <section class="card" id="scoreBoard" style="display:none">
    <div class="row" style="justify-content:space-between">
      <h3 style="margin:0">×œ×•×— ×”×•×‘×œ×”</h3>
      <div class="row">
        <button class="btn bad" id="btnResetPoints">××™×¤×•×¡ × ×§×•×“×•×ª</button>
        <button class="btn secondary" id="btnBack">×—×–×¨×” ×œ×©××•×ª</button>
      </div>
    </div>
    <table id="tbl">
      <thead>
        <tr><th>#</th><th>×©×</th><th>× ×§×•×“×•×ª</th><th>×¤×¢×•×œ×•×ª</th><th>ğŸ“·</th></tr>
      </thead>
      <tbody></tbody>
    </table>
    <div class="tiny" id="lastPred">×–×™×”×•×™ ××—×¨×•×Ÿ: â€”</div>
  </section>

  <!-- TRAINER ALWAYS OPEN -->
  <section class="card" id="trainer">
    <h3>××™××•×Ÿ ××•×“×œ ×–×™×”×•×™ (CPU)</h3>
    <div class="row" style="margin-bottom:8px">
      <label for="cls" class="tiny">×‘×—×¨/×™ ××—×œ×§×” (××¡×¤×¨):</label>
      <select id="cls"><option>1</option><option>2</option><option>3</option><option>4</option><option>5</option><option>6</option><option>7</option><option>8</option><option>9</option><option>10</option><option>11</option><option>12</option><option>13</option></select>
      <button id="btnClear" class="btn bad" disabled>× ×§×” ×”×›×œ</button>
      <span class="tiny">upload â†’ embedding (MobileNet) â†’ KNN</span>
    </div>

    <div id="drop" class="drop">
      ×’×¨×¨×• ×ª××•× ×•×ª ×œ×›××Ÿ ××• ×œ×—×¦×• ×œ×‘×—×™×¨×”
      <input id="file" type="file" accept="image/*,.heic,.heif" multiple disabled>
    </div>

    <div class="row" style="margin-top:8px">
      <button id="btnCam" class="btn" disabled>ğŸ“· ××¦×œ××”</button>
      <input id="cam" type="file" accept="image/jpeg,image/jpg" capture="environment" style="display:none" disabled>
      <progress id="prog" max="1" value="0" style="width:220px"></progress>
      <span id="status" class="tiny"></span>
    </div>

    <div id="thumbs" class="thumbs"></div>

    <div class="card" style="margin-top:12px">
      <div class="row" style="justify-content:space-between"><b>Debug</b>
        <button id="copyDbg" class="btn secondary">ğŸ“‹ ×”×¢×ª×§</button></div>
      <pre id="dbg"></pre>
    </div>
  </section>
</main>

<canvas id="work" width="224" height="224" style="display:none"></canvas>

<script>
// ======== ML CORE ========
let net, classifier, ready=false;
const dbg = (m)=>{ const el=document.getElementById('dbg'); el.textContent += (el.textContent?'\n':'')+m; el.scrollTop=el.scrollHeight; };
function setCounts(){
  const ds = classifier.getClassifierDataset(); const ks = Object.keys(ds);
  const txt = ks.length? ks.map(k=> k+': '+(ds[k].shape[0]||0)).join(' | ') : 'â€”';
  document.getElementById('counts').textContent = '×“×•×’×××•×ª: '+txt;
}
async function initML(){
  try{ await tf.setBackend('cpu'); await tf.ready(); document.getElementById('tfBadge').textContent='TF: '+tf.getBackend(); dbg('backend: '+tf.getBackend()); }
  catch(e){ dbg('TF init error: '+(e&&e.message||e)); }
  try{ net = await mobilenet.load({version:2, alpha:0.5}); classifier = knnClassifier.create(); ready=true;
        document.getElementById('mdlBadge').textContent='model: ready'; enableTrainer(true); dbg('models loaded'); }
  catch(e){ document.getElementById('mdlBadge').textContent='model: error'; dbg('model load error: '+(e&&e.message||e)); }
}
function enableTrainer(on){
  ['file','cam','btnCam','btnClear'].forEach(id=>{ const el=document.getElementById(id); if(el) el.disabled=!on; });
}
function waitImage(url){
  return new Promise((resolve,reject)=>{ const img=new Image(); img.onload=()=>resolve(img); img.onerror=()=>reject(new Error('image load failed')); img.src=url; });
}
async function toTensor(img){
  const c=document.getElementById('work'), ctx=c.getContext('2d', { willReadFrequently:true });
  const w=img.naturalWidth||img.width, h=img.naturalHeight||img.height; const s=Math.min(w,h)||1;
  const sx=(w-s)/2, sy=(h-s)/2; ctx.clearRect(0,0,224,224); ctx.drawImage(img,sx,sy,s,s,0,0,224,224);
  return tf.tidy(()=> tf.browser.fromPixels(c));
}
async function addExamplesFromFiles(list, cls){
  if(!list || !list.length) return;
  if(!ready){ dbg('models not ready'); return; }
  const prog=document.getElementById('prog'); prog.max=list.length; prog.value=0;
  let ok=0, fail=0;
  for(const f of list){
    try{ const url=URL.createObjectURL(f); addThumb(url);
          const img=await waitImage(url); URL.revokeObjectURL(url);
          const px=await toTensor(img);
          const emb=tf.tidy(()=> net.infer(px.expandDims(0),'conv_preds'));
          classifier.addExample(emb, cls); emb.dispose(); px.dispose(); ok++; dbg('âœ… added '+f.name+' to class '+cls); }
    catch(e){ fail++; dbg('ERR addExample '+(e&&e.message||e)); }
    prog.value = ok+fail;
  }
  document.getElementById('status').textContent='×”×•×¡×¤×• '+ok+' | × ×›×©×œ×• '+fail; setCounts();
}
function addThumb(src){ const img=new Image(); img.src=src; img.className='thumb'; document.getElementById('thumbs').appendChild(img);}
async function classifyFile(file){
  if(!ready) return {ok:false, reason:'not ready'};
  if(!classifier.getNumClasses()) return {ok:false, reason:'no classes'};
  try{ const url=URL.createObjectURL(file); const img=await waitImage(url); URL.revokeObjectURL(url);
        const px=await toTensor(img); const emb=tf.tidy(()=> net.infer(px.expandDims(0),'conv_preds'));
        const res=await classifier.predictClass(emb); emb.dispose(); px.dispose(); return {ok:true, res}; }
  catch(e){ return {ok:false, reason:e&&e.message||e}; }
}

// ======== GAME ========
let players = []; // [{name, score, id}]
function saveState(){
  localStorage.setItem('rummi.players', JSON.stringify(players));
}
function loadState(){
  try{ players = JSON.parse(localStorage.getItem('rummi.players')||'[]'); }catch(_){}
}
function startGame(){
  const names = [p1.value,p2.value,p3.value,p4.value].map(s=>s.trim()).filter(Boolean);
  players = names.map((n,i)=>({id:i+1,name:n,score:0})); saveState(); renderBoard();
  document.getElementById('gameSetup').style.display='none';
  document.getElementById('scoreBoard').style.display='block';
}
function backToNames(){
  document.getElementById('scoreBoard').style.display='none';
  document.getElementById('gameSetup').style.display='block';
}
function delta(i, d){
  players[i].score += d; renderBoard(); saveState();
}
async function snapAndAdd(i){
  return openCamForPlayer(i);
  /* old file-input path is disabled to avoid HEIC issues */

  const input = document.createElement('input'); input.type='file'; input.accept='image/jpeg,image/jpg'; input.capture='environment';
  input.onchange = async (e)=>{
    const f=e.target.files&&e.target.files[0]; if(!f) return;
    const clsRes = await classifyFile(f);
    if(!clsRes.ok){ document.getElementById('lastPred').textContent='×–×™×”×•×™ × ×›×©×œ: '+clsRes.reason; return; }
    const label = clsRes.res.label; const prob = (clsRes.res.confidences[label]||0);
    document.getElementById('lastPred').textContent = '×–×™×”×•×™ ××—×¨×•×Ÿ: '+label+' ('+(prob*100).toFixed(0)+'%) â†’ ×œ×©×—×§×Ÿ/×™×ª '+players[i].name;
    const val = parseInt(label,10)||0; players[i].score += val; renderBoard(); saveState();
  };
  input.click();
}
function renderBoard(){
  const tb = document.querySelector('#tbl tbody'); tb.innerHTML='';
  players.forEach((p,i)=>{
    const tr=document.createElement('tr');
    tr.innerHTML = `
      <td class="tiny">\${i+1}</td>
      <td><b>\${p.name}</b></td>
      <td><span class="pill">\${p.score}</span></td>
      <td>
        <button class="btn bad" data-i="\${i}" data-d="-10">-10</button>
        <button class="btn" data-i="\${i}" data-d="10">+10</button>
        <input class="custom" data-i="\${i}" type="text" inputmode="numeric" placeholder="+/- ×¢×¨×š">
        <button class="btn secondary apply" data-i="\${i}">×”×•×¡×£/×™</button>
      </td>
      <td><button class="btn" data-snap="\${i}">ğŸ“·</button></td>`;
    tb.appendChild(tr);
  });
  // wire buttons
  tb.querySelectorAll('button[data-d]').forEach(btn=> btn.onclick=()=> delta(parseInt(btn.dataset.i), parseInt(btn.dataset.d)));
  tb.querySelectorAll('button.apply').forEach(btn=> btn.onclick=()=>{ const i=parseInt(btn.dataset.i);
    const inp = btn.parentElement.querySelector('input.custom'); const v=parseInt((inp.value||'').trim(),10); if(!isNaN(v)) delta(i, v); inp.value='';
  });
  tb.querySelectorAll('button[data-snap]').forEach(btn=> btn.onclick=()=> snapAndAdd(parseInt(btn.dataset.snap)));
}

// ======== WIRING ========
window.addEventListener('DOMContentLoaded',()=>{
  initML();
  loadState();
  // If we have saved players, go straight to board
  if(players.length){ document.getElementById('gameSetup').style.display='none'; document.getElementById('scoreBoard').style.display='block'; renderBoard(); }
  document.getElementById('btnStart').onclick=startGame;
  document.getElementById('btnBack').onclick=backToNames;
  document.getElementById('btnResetPoints').onclick=()=>{ players.forEach(p=>p.score=0); saveState(); renderBoard(); };

  // Trainer events
  const drop=document.getElementById('drop'), file=document.getElementById('file'), cam=document.getElementById('cam');
  document.getElementById('btnCam').onclick=()=> cam.click();
  document.getElementById('btnClear').onclick=()=>{ classifier.clearAllClasses(); setCounts(); dbg('dataset cleared'); document.getElementById('thumbs').innerHTML=''; };
  document.getElementById('copyDbg').onclick=()=> navigator.clipboard.writeText(document.getElementById('dbg').textContent||'');

  file.addEventListener('change', e=>{ dbg('filePick '+(e.target.files?.length||0)); addExamplesFromFiles(e.target.files, document.getElementById('cls').value); });
  cam.addEventListener('change', e=>{ dbg('camPick '+(e.target.files?.length||0)); addExamplesFromFiles(e.target.files, document.getElementById('cls').value); });

  ;['dragenter','dragover'].forEach(ev=> drop.addEventListener(ev, e=>{ e.preventDefault(); drop.classList.add('drag'); }, false));
  ;['dragleave','drop'].forEach(ev=> drop.addEventListener(ev, e=>{ e.preventDefault(); drop.classList.remove('drag'); }, false));
  drop.addEventListener('drop', e=>{ addExamplesFromFiles(e.dataTransfer.files, document.getElementById('cls').value); }, false);
  drop.addEventListener('click', ()=> file.click());
});

// ======== CAMERA OVERLAY (for player capture) ========
let camStream=null, camTargetIndex=null;
async function openCamForPlayer(index){
  try{
    camTargetIndex = index; if(index==null){alert("×œ× × ×‘×—×¨ ×©×—×§×Ÿ"); return; }
    const dlg = document.getElementById('camDlg');
    const video = document.getElementById('camVideo');
    if(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia){
      alert('×”×“×¤×“×¤×Ÿ ×œ× ×ª×•××š ×‘â€‘getUserMedia.');
      return;
    }
    camStream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}});
    video.srcObject = camStream;
    if(typeof dlg.showModal==='function') dlg.showModal(); else dlg.setAttribute('open','');
  }catch(e){
    dbg('openCam error: '+(e&&e.message||e));
    alert('×œ× × ×™×ª×Ÿ ×œ×¤×ª×•×— ××¦×œ××”. ×‘×“×•×§/×™ ×”×¨×©××•×ª.');
  }
}
function closeCam(){
  const dlg = document.getElementById('camDlg');
  try{ if(camStream){ camStream.getTracks().forEach(t=>t.stop()); camStream=null; } }catch(_){}
  if(typeof dlg.close==='function'){ try{ dlg.close(); }catch(_){ dlg.removeAttribute('open'); } }
  else dlg.removeAttribute('open');
}

async function snapFromCamAndClassify(){
  // Guards
  if (typeof players === 'undefined' || !Array.isArray(players) || players.length === 0){
    alert('××™×Ÿ ×©×—×§× ×™× ×‘××©×—×§. ×‘×—×¨/×™ ×©×—×§× ×™× ×•×”×ª×—×œ/×™ ××©×—×§.');
    return;
  }
  if (camTargetIndex == null || !players[camTargetIndex]){
    alert('×œ× × ×‘×—×¨ ×©×—×§×Ÿ ×œ×¦×™×œ×•×.');
    return;
  }
  if(!ready){ alert('×”××•×“×œ ×¢×“×™×™×Ÿ ×œ× ×”×•×›×Ÿ.'); return; }
  if(!classifier.getNumClasses()){ alert('××™×Ÿ ×“×•×’×××•×ª ×‘××•×“×œ. ×”×•×¡×£/×™ ×‘××™××•×Ÿ.'); return; }
  try{
    const video = document.getElementById('camVideo');
    // ensure video has frames
    if(!(video && (video.readyState === 4 || video.videoWidth))){
      await new Promise(r => setTimeout(r, 120));
    }
    const c = document.getElementById('work');
    const ctx = c.getContext('2d', { willReadFrequently:true });
    const w = video.videoWidth || 224, h = video.videoHeight || 224;
    const s = Math.min(w,h), sx = (w - s)/2, sy = (h - s)/2;
    ctx.clearRect(0,0,224,224);
    ctx.drawImage(video, sx, sy, s, s, 0, 0, 224, 224);

    // classify
    const px = tf.browser.fromPixels(c);
    const emb = tf.tidy(()=> net.infer(px.expandDims(0),'conv_preds'));
    const res = await classifier.predictClass(emb);
    emb.dispose(); px.dispose();

    const label = res.label;
    const prob = (res.confidences && res.confidences[label]) || 0;
    const player = players[camTargetIndex];
    document.getElementById('lastPred').textContent =
      '×–×™×”×•×™ ××—×¨×•×Ÿ: ' + label + ' (' + (prob*100).toFixed(0) + '%) â†’ ' + player.name;

    const val = parseInt(label, 10) || 0;
    player.score += val;
    renderBoard();
    saveState();
  }catch(e){
    dbg('snap classify error: '+(e && e.message || e));
    alert('×”×¦×™×œ×•× × ×›×©×œ.');
  }finally{
    closeCam();
  }
}

document.addEventListener('click',(e)=>{
  if(e.target && e.target.id==='camClose') closeCam();
  if(e.target && e.target.id==='camSnap') snapFromCamAndClassify();
});
// ======== END CAMERA OVERLAY ========


// ======== PERSIST TRAINED MODEL (localStorage) ========
const MODEL_LS_KEY = 'rummi_knn_v1';

function datasetToJSON(ds) {
  const out = {};
  let total = 0;
  Object.keys(ds).forEach(label => {
    const t = ds[label]; // Tensor2D
    const data = Array.from(t.dataSync());
    out[label] = {shape: t.shape, data};
    total += t.shape[0];
  });
  return { version: 1, total, ds: out };
}

function jsonToDataset(obj) {
  const out = {};
  Object.keys(obj.ds).forEach(label => {
    const item = obj.ds[label];
    out[label] = tf.tensor(item.data, item.shape, 'float32');
  });
  return out;
}

function saveModelLS() {
  try {
    const ds = classifier.getClassifierDataset();
    if (!ds || !Object.keys(ds).length) return {saved:false, msg:'empty'};
    const json = datasetToJSON(ds);
    const str = JSON.stringify(json);
    localStorage.setItem(MODEL_LS_KEY, str);
    updateModelBadge(`saved â€¢ ${json.total} ex â€¢ ${(str.length/1024).toFixed(1)} KB`);
    return {saved:true, size: str.length, total: json.total};
  } catch (e) {
    dbg('saveModelLS error: ' + (e && e.message || e));
    updateModelBadge('save failed');
    return {saved:false, msg: e && e.message};
  }
}

async function loadModelLS() {
  try {
    const str = localStorage.getItem(MODEL_LS_KEY);
    if (!str) { updateModelBadge('model: none'); return {loaded:false}; }
    const obj = JSON.parse(str);
    const ds = jsonToDataset(obj);
    classifier.setClassifierDataset(ds);
    updateModelBadge(`loaded â€¢ ${obj.total} ex â€¢ ${(str.length/1024).toFixed(1)} KB`);
    return {loaded:true, total: obj.total, size: str.length};
  } catch (e) {
    dbg('loadModelLS error: ' + (e && e.message || e));
    updateModelBadge('load failed');
    return {loaded:false, msg: e && e.message};
  }
}

function updateModelBadge(text){
  const el = document.getElementById('modelBadge');
  if (el) el.textContent = text;
}

// Auto-save throttle: if dataset changes size, save after 1s
let lastSaveTotal = 0;
function getTotalExamples(){
  try{
    const ds = classifier.getClassifierDataset();
    if(!ds) return 0;
    let tot=0; Object.values(ds).forEach(t=> tot += t.shape[0]);
    return tot;
  }catch(_){ return 0; }
}
async function autoSaveTick(){
  try{
    const tot = getTotalExamples();
    if(tot && tot !== lastSaveTotal){
      const r = saveModelLS();
      if(r.saved){ lastSaveTotal = r.total || tot; }
    }
  }finally{
    setTimeout(autoSaveTick, 1500);
  }
}

// Load on startup (after models are ready); if loaded -> set lastSaveTotal so we don't resave immediately.
window.addEventListener('DOMContentLoaded', ()=>{
  // defer a bit to let classifier exist
  setTimeout(async ()=>{
    try{
      if (typeof classifier !== 'undefined'){
        const r = await loadModelLS();
        if(r.loaded){ lastSaveTotal = r.total || 0; }
        autoSaveTick();
      }
    }catch(e){ dbg('persist init error: '+(e&&e.message||e)); }
  }, 800);
});
// ======== END PERSIST ========

</script>

<dialog id="camDlg" style="border:none;border-radius:16px;padding:0;overflow:hidden;max-width:96vw">
  <div style="background:#0b1428;color:#eaf1ff;padding:10px 12px;border-bottom:1px solid rgba(255,255,255,.12);display:flex;justify-content:space-between;align-items:center">
    <b>××¦×œ××”</b>
    <button id="camClose" class="btn secondary">×¡×’×•×¨</button>
  </div>
  <div style="background:#000;display:flex;justify-content:center;align-items:center">
    <video id="camVideo" autoplay playsinline style="max-width:96vw;max-height:60vh"></video>
  </div>
  <div style="background:#0b1428;color:#eaf1ff;padding:10px;display:flex;gap:10px;justify-content:center;border-top:1px solid rgba(255,255,255,.12)">
    <button id="camSnap" class="btn good">×¦×œ×</button>
  </div>
</dialog>


<div style="position:fixed;inset-inline-end:10px;inset-block-end:10px;display:flex;gap:8px;z-index:30">
  <button id="btnSaveModelNow" class="btn secondary" style="opacity:.85">×©××•×¨ ××•×“×œ</button>
  <button id="btnClearModelLS" class="btn danger" style="opacity:.85">××™×¤×•×¡ ××•×“×œ</button>
</div>
<script>
document.addEventListener('click',(e)=>{
  if(e.target && e.target.id==='btnSaveModelNow'){ saveModelLS(); }
  if(e.target && e.target.id==='btnClearModelLS'){
    localStorage.removeItem(MODEL_LS_KEY);
    updateModelBadge('model: cleared');
  }
});
</script>

<script>
// ------- Patch: robust player names + rendering -------
function safeName(x, idx){
  const t = (x||'').toString().trim();
  return t ? t : ('×©×—×§×Ÿ ' + (idx+1));
}
function fmtScore(n){ try{ return (n|0).toString(); }catch(_){ return '0'; } }

// Override startGame to normalize names and persist
if (typeof startGame === 'function'){
  const _origStartGame = startGame;
  startGame = function(){
    try{
      if(Array.isArray(players)){
        players = players.map((p,i)=>({ name: safeName(p && p.name, i), score: (p && p.score|0)||0 }));
        localStorage.setItem('rummi_players', JSON.stringify(players));
      }
    }catch(_){}
    _origStartGame();
    renderBoard(); // ensure UI refresh
  }
}

// Read players from LS on load
window.addEventListener('DOMContentLoaded', ()=>{
  try{
    const s = localStorage.getItem('rummi_players');
    if(s){
      const arr = JSON.parse(s);
      if(Array.isArray(arr) && arr.length){
        players = arr.map((p,i)=>({ name: safeName(p && p.name, i), score: (p && p.score|0)||0 }));
      }
    }
  }catch(_){}
  if(typeof renderBoard === 'function') setTimeout(renderBoard, 200);
});

// Override renderBoard safely
window.renderBoard = function(){
  try{
    const tbody = document.getElementById('playersTbody') || document.querySelector('[data-players-tbody]');
    if(!tbody || !Array.isArray(players)) return;
    tbody.innerHTML = players.map((p, i)=>{
      const name = safeName(p.name, i);
      const score = fmtScore(p.score||0);
      return `
      <tr>
        <td class="idx">${i+1}</td>
        <td class="name">${name}</td>
        <td class="score" id="score_${i}">${score}</td>
        <td class="actions">
          <button class="btn add10" data-idx="${i}" data-delta="10">+10</button>
          <button class="btn sub10" data-idx="${i}" data-delta="-10">-10</button>
          <div class="adder">
            <input type="number" inputmode="numeric" class="narrow" id="add_${i}" placeholder="×¢×¨×š">
            <button class="btn doadd" data-idx="${i}">×”×•×¡×£/×™</button>
          </div>
          <button class="btn cam" data-cam="${i}">ğŸ“·</button>
        </td>
      </tr>`;
    }).join('');
  }catch(e){ console.log('renderBoard error', e); }
};

// Actions delegation
document.addEventListener('click', (e)=>{
  const t = e.target;
  if(t.matches('.doadd')){
    const i = parseInt(t.dataset.idx,10);
    const el = document.getElementById('add_'+i);
    const val = parseInt(el && el.value, 10) || 0;
    if(players[i]){ players[i].score = (players[i].score|0) + val; }
    localStorage.setItem('rummi_players', JSON.stringify(players));
    renderBoard();
  }
  if(t.matches('.add10, .sub10')){
    const i = parseInt(t.dataset.idx,10);
    const d = parseInt(t.dataset.delta,10);
    if(players[i]){ players[i].score = (players[i].score|0) + d; }
    localStorage.setItem('rummi_players', JSON.stringify(players));
    renderBoard();
  }
  if(t.matches('.cam')){
    const i = parseInt(t.dataset.cam,10);
    if(!players[i]){ alert('×œ× × ××¦× ×©×—×§×Ÿ ×œ×¦×™×œ×•×'); return; }
    if(typeof openCamForPlayer === 'function'){ openCamForPlayer(i); }
  }
});
</script>


<script>
// ---- v2.65 players name hardening ----
function ensurePlayers(min=2){
  if(!Array.isArray(window.players)) window.players = [];
  // normalize
  window.players = window.players.map((p,i)=>({
    name: (p && (''+p.name).trim()) || ('×©×—×§×Ÿ ' + (i+1)),
    score: (p && (p.score|0)) || 0
  }));
  while(window.players.length < min){
    const i = window.players.length;
    window.players.push({ name: '×©×—×§×Ÿ ' + (i+1), score: 0 });
  }
  try{ localStorage.setItem('rummi_players', JSON.stringify(window.players)); }catch(_){}
}
window.addEventListener('DOMContentLoaded', ()=>{
  try{
    const s = localStorage.getItem('rummi_players');
    if(s){
      const arr = JSON.parse(s);
      if(Array.isArray(arr)) window.players = arr;
    }
  }catch(_){}
  ensurePlayers(2);
  if(typeof renderBoard==='function') setTimeout(renderBoard, 50);
});

// Hook any start-game button to also ensure players are valid
document.addEventListener('click', (e)=>{
  if(e.target && e.target.matches('[data-start-game],#btnStartGame')){
    ensurePlayers(2);
    if(typeof renderBoard==='function') renderBoard();
  }
});
</script>


<script>
// ===== v2.66 players mount hardening =====
(function(){
  const heb = {
    boardTitle: '×œ×•×— ×”×•×‘×œ×”',
    idx: '#',
    name: '×©×',
    points: '× ×§×•×“×•×ª',
    actions: '×¤×¢×•×œ×•×ª',
    add10: '+10',
    sub10: '-10',
    add: '×”×•×¡×¤/×™',
    value: '×¢×¨×š',
  };
  function ensurePlayers(min=2){
    if(!Array.isArray(window.players)) window.players = [];
    window.players = window.players.map((p,i)=>({
      name: (p && (''+p.name).trim()) || ('×©×—×§×Ÿ ' + (i+1)),
      score: (p && (p.score|0)) || 0
    }));
    while(window.players.length < min){
      const i = window.players.length;
      window.players.push({ name: '×©×—×§×Ÿ ' + (i+1), score: 0 });
    }
    try{ localStorage.setItem('rummi_players', JSON.stringify(window.players)); }catch(_){}
  }
  function mountTable(){
    let root = document.querySelector('[data-players-root]');
    if(!root){
      // try to find existing leaderboard container
      root = document.getElementById('playersRoot');
    }
    if(!root){
      // create compact board near top if not found
      const host = document.createElement('section');
      host.setAttribute('dir','rtl');
      host.style.margin="12px 0";
      host.innerHTML = `
        <div class="card" style="padding:12px;border-radius:10px;background:#0e1726;border:1px solid #223;box-shadow:0 2px 6px rgba(0,0,0,.3)">
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
            <h3 style="margin:0;font-size:18px">${heb.boardTitle}</h3>
          </div>
          <div class="tableWrap" style="overflow:auto">
            <table style="width:100%;border-collapse:collapse">
              <thead>
                <tr>
                  <th style="text-align:right;padding:6px">${heb.idx}</th>
                  <th style="text-align:right;padding:6px">${heb.name}</th>
                  <th style="text-align:right;padding:6px">${heb.points}</th>
                  <th style="text-align:right;padding:6px">${heb.actions}</th>
                </tr>
              </thead>
              <tbody id="playersTbody" data-players-tbody></tbody>
            </table>
          </div>
        </div>`;
      document.body.insertBefore(host, document.body.firstChild.nextSibling);
    }
  }
  function renderBoard(){
    ensurePlayers(2);
    mountTable();
    const tbody = document.getElementById('playersTbody') || document.querySelector('[data-players-tbody]');
    if(!tbody) return;
    const rows = window.players.map((p,i)=>{
      const name = (p && (''+p.name).trim()) || ('×©×—×§×Ÿ ' + (i+1));
      const score = (p && (p.score|0)) || 0;
      return `<tr>
        <td style="padding:6px">${i+1}</td>
        <td style="padding:6px">${name}</td>
        <td style="padding:6px" id="score_${i}">${score}</td>
        <td style="padding:6px;display:flex;gap:6px;flex-wrap:wrap">
          <button class="btn small delta" data-idx="${i}" data-delta="10">${heb.add10}</button>
          <button class="btn small delta" data-idx="${i}" data-delta="-10">${heb.sub10}</button>
          <input type="number" inputmode="numeric" class="narrow" id="add_${i}" placeholder="${heb.value}" style="width:70px">
          <button class="btn small doadd" data-idx="${i}">${heb.add}</button>
          <button class="btn small cam" data-cam="${i}">ğŸ“·</button>
        </td>
      </tr>`;
    }).join('');
    tbody.innerHTML = rows;
  }
  window.renderBoard = renderBoard;
  window.addEventListener('DOMContentLoaded', ()=>{
    // attempt load from LS
    try{
      const s = localStorage.getItem('rummi_players');
      if(s){
        const arr = JSON.parse(s);
        if(Array.isArray(arr)) window.players = arr;
      }
    }catch(_){}
    renderBoard();
  });
  document.addEventListener('click', (e)=>{
    const t = e.target;
    if(t.matches('.delta')){
      const i = parseInt(t.dataset.idx,10), d = parseInt(t.dataset.delta,10);
      if(window.players[i]) window.players[i].score = (window.players[i].score|0) + d;
      try{ localStorage.setItem('rummi_players', JSON.stringify(window.players)); }catch(_){}
      renderBoard();
    }else if(t.matches('.doadd')){
      const i = parseInt(t.dataset.idx,10);
      const el = document.getElementById('add_'+i);
      const v = parseInt(el && el.value, 10) || 0;
      if(window.players[i]) window.players[i].score = (window.players[i].score|0) + v;
      try{ localStorage.setItem('rummi_players', JSON.stringify(window.players)); }catch(_){}
      renderBoard();
    }else if(t.matches('.cam')){
      const i = parseInt(t.dataset.cam,10);
      if(window.openCamForPlayer) window.openCamForPlayer(i);
      else alert('×¦×™×œ×•× ×–××™×Ÿ ×××©×—×§');
    }
  });
})();
</script>

</body>
</html>
