<!DOCTYPE html>

<html dir="rtl" lang="he">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<title>×¨××™×§×•×‘ â€“ × ×™×§×•×“ + ××™××•×Ÿ (CPU)</title>
<style>
  :root{
    --bg:#0f1724; --panel:#121c2b; --muted:#9fb3c8; --text:#eaf6ff;
    --acc:#89e3ff; --good:#2ecc71; --bad:#c14949;
  }
  html,body{height:100%}
  body{margin:0;background:linear-gradient(180deg,#0b1420,#0e1623 40%,#0b1420);
       color:var(--text);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji",sans-serif}
  .wrap{max-width:920px;margin:0 auto;padding:14px 14px 48px}
  .row{display:flex;flex-wrap:wrap;gap:12px}
  .pill{display:inline-flex;align-items:center;gap:.5rem;padding:.35rem .7rem;border-radius:999px;background:#122235;color:#d7edff;font-size:.9rem}
  .muted{color:var(--muted)}
  h2{margin:.6rem 0 0.2rem;font-size:1.35rem}
  h3{margin:1rem 0 .4rem;font-size:1.1rem;color:#cfeaff}
  .card{background:var(--panel);border-radius:14px;padding:14px;box-shadow:0 6px 24px rgba(0,0,0,.25);margin:10px 0}
  .board .thead, .board .row{display:grid;grid-template-columns:42px 1fr 100px 190px;gap:10px;align-items:center}
  .board .thead{opacity:.8;padding-bottom:6px;border-bottom:1px solid #1e2a3c}
  .board .row{padding:6px 0;border-bottom:1px dashed #1a2537}
  .btn{border:0;border-radius:10px;padding:.48rem .7rem;background:#16314a;color:#e9f6ff;cursor:pointer}
  .btn:hover{filter:brightness(1.1)}
  .btn.bad{background:#3a1e26;color:#ffc7c7}
  .btn.good{background:#113021;color:#c6ffd9}
  .btn.acc{background:#14344a;color:#bfefff}
  .btn.cam{display:inline-flex;gap:.35rem;align-items:center}
  input[type="text"], input[type="number"]{width:100%;padding:.48rem .6rem;border-radius:10px;background:#0d1522;border:1px solid #1c2a3c;color:#eaf6ff}
  .hint{font-size:.85rem;color:#94adc4}
  .grid2{display:grid;grid-template-columns:1fr 1fr;gap:12px}
  .kbd{background:#0b1420;border:1px solid #203049;padding:.15rem .45rem;border-radius:6px}
  .sep{height:1px;background:#1a2738;margin:.75rem 0}
  .footer{position:sticky;bottom:0;backdrop-filter:blur(8px);background:rgba(8,13,22,.75);border-top:1px solid #22324a;padding:10px;margin:0 -14px}
  small.tag{background:#0f263a;color:#d2f1ff;border:1px solid #234761;border-radius:999px;padding:.15rem .55rem;margin-inline-end:.35rem}
  .ghost{opacity:.35}
  .flex{display:flex;gap:.5rem;align-items:center}
  .btn.inline{padding:.35rem .55rem;border-radius:8px}
  .nowrap{white-space:nowrap}
  .danger{color:#ffb2b2}
  .ok{color:#baffc3}
  .scrollx{overflow:auto}
  .copybtn{margin-inline-start:.5rem}
</style>
</head>
<body>
<div class="wrap" id="app">
<div class="row" style="justify-content:space-between;align-items:center">
<div class="flex">
<small class="tag" id="verBadge">v6.6-ml</small>
<small class="tag" id="tfBadge">TF: init</small>
<small class="tag" id="modelBadge">model: â€”</small>
<small class="tag" id="examplesBadge">×“×•×’×××•×ª: â€”</small>
</div>
<div class="flex">
<button class="btn inline" id="btnResetScores">××™×¤×•×¡ × ×§×•×“×•×ª</button>
<button class="btn inline" id="btnSaveNames">×©××•×¨ ×©××•×ª</button>
</div>
</div>
<!-- ×œ×•×— ×”×•×‘×œ×” ×™×—×™×“ -->
<div class="card board" id="leaderCard">
<div class="row" style="justify-content:space-between;align-items:center">
<h2 style="margin:0">×œ×•×— ×”×•×‘×œ×”</h2>
<div class="hint"><span class="kbd">+10</span>/<span class="kbd">-10</span> ×ª×¢×“×›×Ÿ × ×§×•×“×•×ª, ××• ×”×•×¡×™×¤×• ×™×“× ×™×ª.</div>
</div>
<div class="thead">
<div>#</div>
<div>×©×</div>
<div>× ×§×•×“×•×ª</div>
<div>×¤×¢×•×œ×•×ª</div>
</div>
<div id="boardRows"></div>
</div>
<!-- ×‘×—×™×¨×ª ××©×ª×ª×¤×™× -->
<div class="card">
<h2>×‘×—×™×¨×ª ××©×ª×ª×¤×™× (×¢×“ 4)</h2>
<div class="grid2">
<div><label class="hint">×©×—×§×Ÿ 1</label><input id="p1" placeholder="×©×" type="text"/></div>
<div><label class="hint">×©×—×§×Ÿ 2</label><input id="p2" placeholder="×©×" type="text"/></div>
<div><label class="hint">×©×—×§×Ÿ 3</label><input id="p3" placeholder="×©×" type="text"/></div>
<div><label class="hint">×©×—×§×Ÿ 4</label><input id="p4" placeholder="×©×" type="text"/></div>
</div>
<div class="row" style="margin-top:10px">
<button class="btn acc" id="btnStart">×”×ª×—×œ ××©×—×§</button>
<div class="hint">×”×©××•×ª × ×©××¨×™× ××§×•××™×ª.</div>
</div>
</div>
<!-- ××™××•×Ÿ ××•×“×œ â€“ ×ª××™×“ ×’×œ×•×™ (×¢×œ ×”××›×©×™×¨) -->
<div class="card" id="trainCard">
<div id="lastDetectWrap" style="position:sticky;bottom:0;z-index:5;background:#0d1117;border-top:1px solid #263040;padding:8px 12px;display:flex;gap:12px;align-items:center"><div id="lastDetectLabel">×–×™×”×•×™ ××—×¨×•×Ÿ: â€”</div><img id="lastDetectImg" style="height:48px;width:36px;object-fit:cover;border-radius:6px;display:none"/><div id="snapThumbs" style="display:flex;gap:6px;flex-wrap:wrap;margin-inline-start:8px;"></div></div><h2>××™××•×Ÿ ××•×“×œ ×–×™×”×•×™ (CPU)</h2>
<div class="hint">upload â†’ embedding (MobileNet) â†’ KNN â€¢ ×”××•×“×œ × ×©××¨/× ×˜×¢×Ÿ ×Ö¾localStorage (×œ× × ×©×œ×— ×œ×¨×©×ª).</div>
<div class="sep"></div>
<div class="row" style="align-items:center;gap:10px">
<label class="hint">×‘×—×¨/×™ ××—×œ×§×” (××¡×¤×¨):</label>
<input id="classId" max="4" min="1" style="width:5rem" type="number" value="1"/>
<button class="btn inline" id="btnNukeExamples">× ×§×” ×”×›×œ</button>
<button class="btn inline" id="btnInitModel">××ª×—×œ ××•×“×œ</button>
<button class="btn inline" id="btnSaveModel">×©××•×¨ ××•×“×œ</button>
<button class="btn inline" id="btnLoadModel">×©×—×–×¨ ××•×“×œ</button>
<button class="btn inline" id="btnExportJSON">JSON ×™×™×¦×</button>
<label class="btn inline nowrap">
        ×™×™×‘× JSON
        <input accept="application/json" hidden="" id="jsonIn" type="file"/>
</label>
<span class="hint">××¦×‘: <span id="statusSpan">××•×›×Ÿ</span></span>
</div>
<div class="row" style="margin-top:10px;align-items:center;gap:10px">
<label class="btn inline nowrap">
        ×”×•×¡×£ ××’×–â€™×™×¨ (×’×œ×¨×™×”)
        <input accept="image/*" hidden="" id="filePick" multiple="" type="file"/>
</label>
<label class="btn inline nowrap">
        ×¦×™×œ×•× ××”××¦×œ××”
        <input accept="image/*" capture="environment" hidden="" id="filePickCam" type="file"/>
</label>
</div>
<div class="sep"></div>
<div class="scrollx">
<pre id="debug" style="min-height:80px;margin:0;background:#0b1420;border:1px solid #22324a;border-radius:12px;padding:10px;white-space:pre-wrap"></pre>
</div>
</div>
<div class="footer row" style="justify-content:space-between">
<div class="hint">×§×™×¦×•×¨ ×“×¨×š: <span class="kbd">×©××•×¨ ××•×“×œ</span> ×©×•××¨ ×œÖ¾localStorage â€¢ <span class="kbd">×©×—×–×¨ ××•×“×œ</span> ×˜×•×¢×Ÿ ××•×˜×•××˜×™×ª ×¢× ×¤×ª×™×—×ª ×”×¢××•×“.</div>
<div class="muted">Â© v6.6-ml</div>
</div>
</div>
<!-- TFJS + MobileNet + KNN (×’×¨×¡××•×ª ×©× ×‘×“×§×•) -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js">
// === ×”×•×¡×¤×ª × ×§×•×“×•×ª ××”×–×™×”×•×™ ×œ×©×—×§×Ÿ ===
function awardPointsFromDetection(playerIdx, points) {
  try {
    if (typeof points !== 'number' || !isFinite(points) || points <= 0) return;
    if (Array.isArray(window.players) && window.players[playerIdx]) {
      window.players[playerIdx].score = (window.players[playerIdx].score || 0) + points;
    }
    // ×¢×“×›×•×Ÿ UI ×× ×™×©
    let row = document.querySelectorAll('.board-row')[playerIdx];
    let scoreEl = row ? row.querySelector('.score') : null;
    if (scoreEl) {
      const newScore = window.players[playerIdx].score;
      scoreEl.textContent = newScore;
    }
    // ×”×¦×’×” ×‘×ª×—×ª×™×ª
    const lastDetLabel = document.getElementById('lastDetectLabel');
    if (lastDetLabel) {
      const pName = window.players[playerIdx]?.name || `×©×—×§×Ÿ ${playerIdx+1}`;
      lastDetLabel.textContent = `× ×•×¡×£ ×œ×©×—×§×Ÿ â€œ${pName}â€ ${points} × ×§×³ (×¡×”×´×› ${window.players[playerIdx].score})`;
    }
  } catch(err) {
    console.error("awardPointsFromDetection error", err);
  }
}

</script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@2.1.0">
// === ×”×•×¡×¤×ª × ×§×•×“×•×ª ××”×–×™×”×•×™ ×œ×©×—×§×Ÿ ===
function awardPointsFromDetection(playerIdx, points) {
  try {
    if (typeof points !== 'number' || !isFinite(points) || points <= 0) return;
    if (Array.isArray(window.players) && window.players[playerIdx]) {
      window.players[playerIdx].score = (window.players[playerIdx].score || 0) + points;
    }
    // ×¢×“×›×•×Ÿ UI ×× ×™×©
    let row = document.querySelectorAll('.board-row')[playerIdx];
    let scoreEl = row ? row.querySelector('.score') : null;
    if (scoreEl) {
      const newScore = window.players[playerIdx].score;
      scoreEl.textContent = newScore;
    }
    // ×”×¦×’×” ×‘×ª×—×ª×™×ª
    const lastDetLabel = document.getElementById('lastDetectLabel');
    if (lastDetLabel) {
      const pName = window.players[playerIdx]?.name || `×©×—×§×Ÿ ${playerIdx+1}`;
      lastDetLabel.textContent = `× ×•×¡×£ ×œ×©×—×§×Ÿ â€œ${pName}â€ ${points} × ×§×³ (×¡×”×´×› ${window.players[playerIdx].score})`;
    }
  } catch(err) {
    console.error("awardPointsFromDetection error", err);
  }
}

</script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/knn-classifier@1.2.2">
// === ×”×•×¡×¤×ª × ×§×•×“×•×ª ××”×–×™×”×•×™ ×œ×©×—×§×Ÿ ===
function awardPointsFromDetection(playerIdx, points) {
  try {
    if (typeof points !== 'number' || !isFinite(points) || points <= 0) return;
    if (Array.isArray(window.players) && window.players[playerIdx]) {
      window.players[playerIdx].score = (window.players[playerIdx].score || 0) + points;
    }
    // ×¢×“×›×•×Ÿ UI ×× ×™×©
    let row = document.querySelectorAll('.board-row')[playerIdx];
    let scoreEl = row ? row.querySelector('.score') : null;
    if (scoreEl) {
      const newScore = window.players[playerIdx].score;
      scoreEl.textContent = newScore;
    }
    // ×”×¦×’×” ×‘×ª×—×ª×™×ª
    const lastDetLabel = document.getElementById('lastDetectLabel');
    if (lastDetLabel) {
      const pName = window.players[playerIdx]?.name || `×©×—×§×Ÿ ${playerIdx+1}`;
      lastDetLabel.textContent = `× ×•×¡×£ ×œ×©×—×§×Ÿ â€œ${pName}â€ ${points} × ×§×³ (×¡×”×´×› ${window.players[playerIdx].score})`;
    }
  } catch(err) {
    console.error("awardPointsFromDetection error", err);
  }
}

</script>
<script>
const VERSION = 'v6.6-ml';
const $$ = sel => document.querySelector(sel);
const on = (el,ev,fn) => el.addEventListener(ev,fn);
const log = msg => { const d=$$('#debug'); d.textContent += (d.textContent? '\\n':'') + msg; d.scrollTop=d.scrollHeight; };

// ====== ××¦×‘ ××¤×œ×™×§×¦×™×” ×‘×¡×™×¡×™ (×©××•×ª + × ×™×§×•×“) ======
let players = []; // {name, score}
function loadNames(){
  const saved = JSON.parse(localStorage.getItem('rk_players') || '[]');
  for(let i=0;i<4;i++){
    const val = saved[i]?.name || '';
    $$('#p'+(i+1)).value = val;
  }
}
function saveNames(){
  players = [];
  for(let i=0;i<4;i++){
    const name = ($$('#p'+(i+1)).value || '').trim() || ('×©×—×§×Ÿ ' + (i+1));
    players.push({name, score:0});
  }
  localStorage.setItem('rk_players', JSON.stringify(players));
}
function renderBoard(){
  const holder = $$('#boardRows'); holder.innerHTML='';
  players.forEach((p,idx)=>{
    const row=document.createElement('div'); row.className='row';
    row.innerHTML = `
      <div>${idx+1}</div>
      <div>${p.name}</div>
      <div><span id="sc_${idx}">${p.score}</span></div>
      <div class="flex">
        <button class="btn good" data-d="+10">+10</button>
        <button class="btn bad" data-d="-10">-10</button>
        <input class="manual" type="number" placeholder="×¢×¨×š" style="width:92px">
        <button class="btn acc" data-d="manual">×”×•×¡×£</button>
        <label class="btn cam nowrap">ğŸ“·
          <input class="snap" type="file" accept="image/*" capture="environment" hidden>
        </label>
      </div>`;
    holder.appendChild(row);
    // ××™×¨×•×¢×™×
    const [bPlus,bMinus,inputManual,bManual,labelCam] = row.querySelectorAll('button,input,label');
    bPlus.onclick=()=>bump(idx, +10);
    bMinus.onclick=()=>bump(idx, -10);
    bManual.onclick=()=>{
      const v = parseInt(inputManual.value||'0',10);
      if(!isNaN(v)) bump(idx, v);
    };
    labelCam.querySelector('input.snap').onchange = async (e)=>{
      // ×ª××•× ×ª ×©×—×§×Ÿ -> ×›×¨×’×¢ ×¨×§ ××¦×™×’×” ×—×™×•×•×™; (×”××•×“×œ × ×©××¨ ××•×“×•×œ ××™××•×Ÿ ×œ××˜×”).
      if(e.target.files?.length){
        log(`ğŸï¸ × ×§×œ×˜ ×¦×™×œ×•× ×œ×©×—×§×Ÿ ${idx+1} (${players[idx].name}).`);
        
// show textual indication only
showLastDetect(idx, e.target.files[0]);
try{
  await ensureModels?.();
  const {img} = await imgToTensor(e.target.files[0]);
  let detected = null, confPct = 0;
  if (typeof net !== 'undefined' && net?.infer && typeof classifier !== 'undefined' && classifier?.predictClass){
    const emb = net.infer(img, true);
    const res = await classifier.predictClass(emb, 3);
    if(res && res.label != null){
      detected = parseInt(res.label,10);
      confPct = Math.round(Math.max(...Object.values(res.confidences||{}))*100);
    }
  }
  const lbl = document.getElementById('lastDetectLabel');
  if(lbl){
    if(detected || detected===0){
      lbl.textContent = `×–×™×”×•×™ ××—×¨×•×Ÿ: ×©×—×§×Ÿ ${idx+1} â€¢ ${players[idx]?.name||''} â€” ×–×•×”×ª×” ×§×•×‘×™×™×”: ${detected} (${confPct}%)`;
    }else{
      lbl.textContent = `×–×™×”×•×™ ××—×¨×•×Ÿ: ×©×—×§×Ÿ ${idx+1} â€¢ ${players[idx]?.name||''} â€” ×œ× ×–×•×”×ª×” ×§×•×‘×™×™×”`;
    }
  }
  // ××™×œ×•×™ ×ª×™×‘×ª '×¢×¨×š' ×‘×©×•×¨×ª ×”×©×—×§×Ÿ ×”× ×›×•×Ÿ
  if(Number.isFinite(detected)) { try{ (row.querySelector('input.manual')||row.querySelector('input[type="number"]')).value = detected; }catch(_){ } }
  // ×× ×™×© ×–×™×”×•×™ × ×©×ª××© ×‘×× ×’× ×•×Ÿ ×”× ×§×•×“×•×ª ×”×§×™×™× (×× ×‘×™×§×©×ª ×‘×¢×‘×¨)
  if(typeof detected !== 'undefined' && detected){
    if(typeof awardPointsFromDetection === 'function'){
      awardPointsFromDetection(idx, detected);
    }
  }
}catch(_){ /* keep silent */ }
if(typeof detectedValue!=='undefined'){ awardPointsFromDetection(idx, detectedValue); }
        // v6.6 segmentation add-on (append thumbs per tile)
        try{
          if(e.target.files && e.target.files[0]){
            const f = e.target.files[0];
            const imgTmp = new Image();
            imgTmp.onload = async ()=>{
              const can = document.createElement('canvas'); can.width=imgTmp.naturalWidth; can.height=imgTmp.naturalHeight;
              can.getContext('2d').drawImage(imgTmp,0,0);
              const tiles = __segmentTiles_v66(can);
              for(const t of tiles){
                const pred = await __classifyTileCanvas(t);
                const txtL = pred ? (pred.label+' â€¢ '+((pred.score*100)|0)+'%') : '';
                __appendTileThumb(t.toDataURL('image/jpeg',0.9), txtL);
              }
            };
            imgTmp.src = URL.createObjectURL(f);
          }
        }catch(_){}
    
      }
    }
  });
}
function bump(index, delta){
  players[index].score += delta;
  $$('#sc_'+index).textContent = players[index].score;
  localStorage.setItem('rk_players', JSON.stringify(players));
}


// == ×–×™×”×•×™ ××—×¨×•×Ÿ â€“ ×ª×¦×•×’×” ==
function showLastDetect(playerIndex, file){
  try{
    const url = URL.createObjectURL(file);
    const imgEl = document.getElementById('lastDetectImg');
    const label = document.getElementById('lastDetectLabel');
    if (label) {
      label.textContent = `×–×™×”×•×™ ××—×¨×•×Ÿ: ×©×—×§×Ÿ ${playerIndex+1} â€¢ ${players[playerIndex].name}`;
    }
    if (imgEl){
      imgEl.src = url;
      imgEl.style.display = 'block';
    }
    // add a small thumbnail of the snap (non-destructive)
    const host = document.getElementById('snapThumbs');
    if (host){
      const thumb = new Image();
      thumb.width = 48; thumb.height = 48;
      thumb.style.borderRadius = '6px';
      thumb.style.border = '1px solid #22324a';
      thumb.style.objectFit = 'cover';
      thumb.onload = ()=>{
        host.prepend(thumb);
        while (host.children.length > 10) host.removeChild(host.lastElementChild);
      };
      thumb.src = url;
    }
    // revoke later to allow display
    setTimeout(()=>{ try{ URL.revokeObjectURL(url); }catch(_){} }, 5000);
  }catch(e){
    log('showLastDetect ERR: ' + (e && e.message || e));
  }
}

// ====== ××ª×—×•×œ ×©××•×ª ×•× ×™×§×•×“ ======
loadNames();
saveNames();
renderBoard();

on($$('#btnSaveNames'),'click',()=>{ saveNames(); renderBoard(); });
on($$('#btnStart'),'click',()=>{ saveNames(); renderBoard(); });
on($$('#btnResetScores'),'click',()=>{
  players.forEach(p=>p.score=0); renderBoard();
  localStorage.setItem('rk_players', JSON.stringify(players));
});

// ====== ××•×“×•×œ ××™××•×Ÿ (MobileNet+KNN) â€“ ×›××• ×‘×’×¨×¡×” ×”×‘×¡×™×¡×™×ª, ×œ×œ× ×©×™× ×•×™ ××”×•×ª×™ ======
let net, classifier;
let totalExamples = 0;

// ×”×›×¨×—×ª CPU â€“ ×œ×‘×™×¦×™×‘×•×ª ×‘××•×‘×™×™×œ
(async ()=>{
  try{
    await tf.setBackend('cpu');
  }catch(e){}
  $$('#tfBadge').textContent = 'TF: ' + tf.getBackend();
})();

async function ensureModels(){
  if(net && classifier) return;
  log('loading mobilenet/knn...');
  classifier = knnClassifier.create();
  net = await mobilenet.load();
  log('models loaded');
  $$('#modelBadge').textContent = 'model: ready';
}

function imgToTensor(file){
  return new Promise((resolve,reject)=>{
    const img = new Image();
    img.onload=()=>{
      const t = tf.tidy(()=>tf.browser.fromPixels(img).toFloat());
      resolve({img, tensor:t});
    };
    img.onerror=reject;
    img.src = URL.createObjectURL(file);
  });
}

async function addExample(file, classId){
  await ensureModels();
  const {img, tensor} = await imgToTensor(file);
  const activation = net.infer(img, true);
  classifier.addExample(activation, classId);
  activation.dispose(); tensor.dispose();
  totalExamples++;
  $$('#examplesBadge').textContent = '×“×•×’×××•×ª: ' + totalExamples;
}

async function handleFiles(files, classId){
  if(!files || files.length===0) return;
  for(const f of files){
    await addExample(f, classId);
  }
  $$('#statusSpan').textContent = `× ×•×¡×¤×• ${files.length} ×“×•×’×××•×ª ×œ××—×œ×§×” ${classId}`;
}

on($$('#filePick'),'change',e=>{
  const classId = parseInt($$('#classId').value,10)||1;
  handleFiles(e.target.files, classId);
});
on($$('#filePickCam'),'change',e=>{
  const classId = parseInt($$('#classId').value,10)||1;
  handleFiles(e.target.files, classId);
});

// × ×™×”×•×œ ××•×“×œ (×™×™×¦×•×/×™×™×‘×•×/×©××™×¨×” ××§×•××™×ª)
function exportJSON(){
  if(!classifier){ alert('××™×Ÿ ××•×“×œ ×˜×¢×•×Ÿ'); return; }
  const dataset = classifier.getClassifierDataset();
  const dataObj = {};
  Object.keys(dataset).forEach(key=>{
    const data = dataset[key].dataSync();
    dataObj[key] = Array.from(data);
  });
  const json = JSON.stringify({dataObj, shape: dataset[Object.keys(dataset)[0]]?.shape || []});
  const blob = new Blob([json], {type:'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'rk_model.json';
  a.click();
}
on($$('#btnExportJSON'),'click', exportJSON);

on($$('#jsonIn'),'change',async e=>{
  const file = e.target.files?.[0]; if(!file) return;
  const text = await file.text();
  restoreFromJSON(text,true);
});

function restoreFromJSON(text, show=true){
  try{
    const obj = JSON.parse(text);
    const dataObj = obj.dataObj || obj.dataset || obj;
    classifier = knnClassifier.create();
    const dataset = {};
    let classes = 0, totalRows = 0;
    Object.keys(dataObj || {}).forEach(key => {
      let arr = dataObj[key];
      if (arr && typeof arr === 'object' && ('data' in arr)) arr = arr.data;
      if (!arr || !arr.length) return;
      const flat = Array.from(arr, Number).filter(n => Number.isFinite(n));
      const rows = Math.floor(flat.length / 1024);
      if (rows <= 0) { log('âš ï¸ skip class '+key+' (no full vectors)'); return; }
      const used = flat.slice(0, rows*1024);
      if (used.length !== flat.length) {
        log('â„¹ï¸  class '+key+': truncated '+(flat.length-used.length)+' to fit 1024 dims');
      }
      const tensor = tf.tensor2d(used, [rows, 1024]);
      dataset[key] = tensor;
      classes += 1; totalRows += rows;
    });
    classifier.setClassifierDataset(dataset);
    totalExamples = totalRows;
    $$('#examplesBadge').textContent = '×“×•×’×××•×ª: ' + totalExamples;
    $$('#modelBadge').textContent = 'model: restored';
    if (show){
      const kb = (text.length/1024).toFixed(1);
      log('ğŸ“¦ restored from JSON â€¢ '+classes+' classes â€¢ '+totalRows+' vectors â€¢ ~'+kb+' KB');
      log('âœ… model restored from JSON');
    }
  }catch(err){
    log('ERR restore: '+err.message);
    alert('×™×™×‘×•× × ×›×©×œ');
  }
}

// ×©××™×¨×”/×©×—×–×•×¨ ×œ-localStorage
on($$('#btnSaveModel'),'click',()=>{
  if(!classifier){ alert('××™×Ÿ ××•×“×œ'); return; }
  const dataset = classifier.getClassifierDataset();
  const dataObj = {};
  Object.keys(dataset).forEach(key=> dataObj[key] = Array.from(dataset[key].dataSync()));
  const payload = JSON.stringify({dataObj, shape: dataset[Object.keys(dataset)[0]]?.shape || []});
  localStorage.setItem('rk_model', payload);
  const bytes = new Blob([payload]).size;
  log(`ğŸ’¾ × ×©××¨ ××§×•××™×ª â€¢ ~${(bytes/1024).toFixed(1)} KB`);
  $$('#modelBadge').textContent = 'model: saved';
});

on($$('#btnLoadModel'),'click',()=>{
  const payload = localStorage.getItem('rk_model');
  if(!payload){ alert('×œ× × ××¦× ××•×“×œ'); return; }
  restoreFromJSON(payload,false);
  const bytes = new Blob([payload]).size;
  log(`ğŸ“¦ ×©×•×—×–×¨ ××§×•××™×ª â€¢ ${(bytes/1024).toFixed(1)} KB`);
  $$('#modelBadge').textContent = 'model: restored';
});

on($$('#btnNukeExamples'),'click',()=>{
  classifier = knnClassifier.create();
  totalExamples = 0;
  $$('#examplesBadge').textContent = '×“×•×’×××•×ª: â€”';
  log('ğŸ§¹ × ×•×§×”.');
});

on($$('#btnInitModel'),'click',()=>{
  // Initialize model: wipe in-memory KNN and clear saved model
  classifier = knnClassifier.create();
  totalExamples = 0;
  $$('#examplesBadge').textContent = '×“×•×’×××•×ª: â€”';
  localStorage.removeItem('rk_model'); // forget saved model
  $$('#modelBadge').textContent = 'model: initialized';
  log('â™»ï¸ ××ª×—×•×œ ××•×“×œ: ×”×“××˜×” × ×•×§×” ×•×”Ö¾localStorage ×”×•×¡×¨');
});

// ××ª×—×•×œ ×¨××©×•× ×™
(async function init(){
  $$('#verBadge').textContent = VERSION;
  try{
    await ensureModels();
    $$('#modelBadge').textContent = 'model: ready';
    // × ×¡×™×•×Ÿ ×œ×©×—×–×¨ ××•×˜×•××˜×™×ª
    const payload = localStorage.getItem('rk_model');
    if(payload){ restoreFromJSON(payload,false); log('auto-restore: ok'); }
  }catch(err){
    log('init error: '+err.message);
  }
})();

// === ×”×•×¡×¤×ª × ×§×•×“×•×ª ××”×–×™×”×•×™ ×œ×©×—×§×Ÿ ===
function awardPointsFromDetection(playerIdx, points) {
  try {
    if (typeof points !== 'number' || !isFinite(points) || points <= 0) return;
    if (Array.isArray(window.players) && window.players[playerIdx]) {
      window.players[playerIdx].score = (window.players[playerIdx].score || 0) + points;
    }
    // ×¢×“×›×•×Ÿ UI ×× ×™×©
    let row = document.querySelectorAll('.board-row')[playerIdx];
    let scoreEl = row ? row.querySelector('.score') : null;
    if (scoreEl) {
      const newScore = window.players[playerIdx].score;
      scoreEl.textContent = newScore;
    }
    // ×”×¦×’×” ×‘×ª×—×ª×™×ª
    const lastDetLabel = document.getElementById('lastDetectLabel');
    if (lastDetLabel) {
      const pName = window.players[playerIdx]?.name || `×©×—×§×Ÿ ${playerIdx+1}`;
      lastDetLabel.textContent = `× ×•×¡×£ ×œ×©×—×§×Ÿ â€œ${pName}â€ ${points} × ×§×³ (×¡×”×´×› ${window.players[playerIdx].score})`;
    }
  } catch(err) {
    console.error("awardPointsFromDetection error", err);
  }
}

</script>

<!-- v6.6-ml minimal patch: fill detected value into the "×¢×¨×š" input next to the correct player -->
<script>
(function(){
  // Helper: safe debug log
  function dlog(msg){
    try {
      var dbg = document.getElementById('debug') || document.querySelector('.debug, #Debug');
      if (!dbg) return;
      var line = (dbg.value ?? dbg.textContent ?? '');
      var add = String(msg);
      if ('value' in dbg) dbg.value = (line ? line + '\n' : '') + add;
      else dbg.textContent = (line ? line + '\n' : '') + add;
      dbg.scrollTop = dbg.scrollHeight;
    } catch(_) {}
  }

  // Try to find the UI row for a given player index
  function getPlayerRow(idx){
    // 1) Preferred: data attribute
    var row = document.querySelector('[data-player-index="'+idx+'"]');
    if (row) return row;
    // 2) Common containers
    var candidates = document.querySelectorAll('#players > * , .boardGrid > * , .board-row, .leaderboard-row, .player-row');
    if (candidates && candidates.length){
      // assume 4 columns per row -> try grouping by 4 (index*4 â€¦ index*4+3)
      if (candidates.length >= (idx*4+1)) {
        var groupStart = idx*4;
        // wrap a div to represent the row if needed
        var wrapper = document.createElement('div');
        for (var i=groupStart;i<Math.min(groupStart+4, candidates.length);i++){
          wrapper.appendChild(candidates[i].cloneNode(true));
        }
        return wrapper; // fallback (will still allow finding an input inside if structure matches)
      }
    }
    // 3) As a last resort, take nth occurrence of a row-like block
    var rows = document.querySelectorAll('.row, .grid, .line');
    if (rows && rows[idx]) return rows[idx];
    return null;
  }

  
  function fillDetectedValue(idx, val){
    try{
      if (!Number.isFinite(val)) return;
      // strictly target the player's own row by data attribute
      var row = document.querySelector('[data-player-index="'+idx+'"]');
      if (!row) return;
      var input = row.querySelector('input.manual') ||
                  row.querySelector('input[type="number"]') ||
                  row.querySelector('input[placeholder="×¢×¨×š"]') ||
                  row.querySelector('input[name="value"]') ||
                  row.querySelector('input[data-role="value"]');
      if (input){
        input.value = val;
        dlog('fill(row-only): idx='+idx+' val='+val);
      } else {
        dlog('fill(row-only): input not found in row for idx='+idx);
      }
    }catch(err){
      dlog('fill error: '+(err && err.message || err));
    }
  }
else {
        dlog('fill: idx='+idx+' val='+val+' -> input not found');
      }
    }catch(err){
      dlog('fill error: '+(err && err.message || err));
    }
  }

  // If awardPointsFromDetection exists, wrap it to ALSO fill the input (without changing its behavior).
  if (typeof window.awardPointsFromDetection === 'function'){
    var __origAward = window.awardPointsFromDetection;
    window.awardPointsFromDetection = function(idx, points){
      // Fill the number box for manual confirmation if desired
      try { fillDetectedValue(idx, Number(points)); } catch(_){}
      // Preserve original behavior exactly
      return __origAward.apply(this, arguments);
    };
    dlog('patch v5.10: wrapped awardPointsFromDetection to fill input');
  } else {
    // Expose a helper for your detection code to call explicitly:
    window.__afterDetected_fillValue_v510 = fillDetectedValue;
    dlog('patch v5.10: expose __afterDetected_fillValue_v510(idx,val)');
  }
})();
</script>

<!-- version updated 1756290570.2479835 --><!-- thumbs patch 1756294700.2569437 -->
// ===== Improved segmentation v6.6 =====
function __segmentTiles_v66(srcCanvas){
  const W = srcCanvas.width, H = srcCanvas.height;
  const ctx = srcCanvas.getContext('2d',{willReadFrequently:true});
  const img = ctx.getImageData(0,0,W,H);
  const data = img.data;
  // grayscale
  const gray = new Uint8ClampedArray(W*H);
  for(let i=0,j=0;i<data.length;i+=4,j++){
    gray[j] = (0.299*data[i] + 0.587*data[i+1] + 0.114*data[i+2])|0;
  }
  // blur
  const blur = new Uint8ClampedArray(W*H);
  for(let y=1;y<H-1;y++){
    for(let x=1;x<W-1;x++){
      let s=0;
      for(let dy=-1;dy<=1;dy++){
        for(let dx=-1;dx<=1;dx++){
          s += gray[(y+dy)*W+(x+dx)];
        }
      }
      blur[y*W+x] = (s/9)|0;
    }
  }
  // Otsu threshold
  const hist=new Array(256).fill(0);
  for(let i=0;i<blur.length;i++) hist[blur[i]]++;
  let sum=0,sumB=0,wB=0,wF=0,max=0,th=127,total=blur.length;
  for(let i=0;i<256;i++) sum+=i*hist[i];
  for(let i=0;i<256;i++){
    wB+=hist[i]; if(wB===0) continue;
    wF=total-wB; if(wF===0) break;
    sumB+=i*hist[i];
    const mB=sumB/wB, mF=(sum-sumB)/wF;
    const between=wB*wF*(mB-mF)*(mB-mF);
    if(between>max){ max=between; th=i; }
  }
  const bin=new Uint8Array(W*H);
  for(let i=0;i<blur.length;i++) bin[i]= blur[i]>th?1:0;

  // connected components
  const seen=new Uint8Array(W*H); const boxes=[]; const stack=[];
  const minArea=(W*H)*0.01, maxArea=(W*H)*0.5;
  for(let y=1;y<H-1;y++){
    for(let x=1;x<W-1;x++){
      const idx=y*W+x;
      if(!bin[idx]||seen[idx]) continue;
      let minx=x,maxx=x,miny=y,maxy=y,area=0;
      stack.push(idx); seen[idx]=1;
      while(stack.length){
        const p=stack.pop();
        const py=(p/W)|0, px=p%W; area++;
        if(px<minx)minx=px;if(px>maxx)maxx=px;if(py<miny)miny=py;if(py>maxy)maxy=py;
        for(const [dx,dy] of [[1,0],[-1,0],[0,1],[0,-1]]){
          const nx=px+dx, ny=py+dy; if(nx<0||ny<0||nx>=W||ny>=H) continue;
          const ni=ny*W+nx;
          if(bin[ni]&&!seen[ni]){seen[ni]=1;stack.push(ni);}
        }
      }
      const bw=maxx-minx+1,bh=maxy-miny+1;
      const areaBox=bw*bh, aspect=bw/bh;
      if(areaBox>minArea && areaBox<maxArea && aspect>0.4 && aspect<2.5){
        const pad=6;
        boxes.push([Math.max(0,minx-pad),Math.max(0,miny-pad),
                    Math.min(W-1,maxx+pad),Math.min(H-1,maxy+pad)]);
      }
    }
  }
  // fallback: if only 1 wide box, split vertically
  if(boxes.length<=1){
    const cuts=[0,Math.floor(W/2),W];
    boxes.length=0;
    for(let i=0;i<cuts.length-1;i++){
      const x1=cuts[i],x2=cuts[i+1];
      boxes.push([x1,0,x2,H]);
    }
  }
  boxes.sort((a,b)=>a[0]-b[0]);
  const out=[];
  for(const [x1,y1,x2,y2] of boxes){
    const cw=x2-x1+1,ch=y2-y1+1;
    const c=document.createElement('canvas'); c.width=cw; c.height=ch;
    c.getContext('2d').drawImage(srcCanvas,x1,y1,cw,ch,0,0,cw,ch);
    out.push(c);
  }
  return out;
}

<script>
// __seg_v66__: robust multi-tile segmentation + per-tile classify (no UI changes)
function __segmentTiles_v66(canvas){
  const W=canvas.width, H=canvas.height;
  const ctx=canvas.getContext('2d', {willReadFrequently:true});
  const {data} = ctx.getImageData(0,0,W,H);
  const gray=new Float32Array(W*H);
  for(let i=0,j=0;i<data.length;i+=4,j++){ gray[j]=(data[i]*0.299+data[i+1]*0.587+data[i+2]*0.114); }
  // Blur 3x3
  const blur=new Float32Array(W*H);
  for(let y=1;y<H-1;y++)for(let x=1;x<W-1;x++){
    let s=0; for(let dy=-1;dy<=1;dy++)for(let dx=-1;dx<=1;dx++){ s+= gray[(y+dy)*W+(x+dx)]; }
    blur[y*W+x]=s/9;
  }
  // Otsu threshold to get binary
  const hist=new Array(256).fill(0); for(let i=0;i<blur.length;i++){ const v=Math.max(0,Math.min(255, blur[i]|0)); hist[v]++; }
  let sum=0; for(let i=0;i<256;i++) sum+= i*hist[i];
  let sumB=0,wB=0,max=0,thr=127, total=blur.length;
  for(let i=0;i<256;i++){ wB+=hist[i]; if(!wB) continue; const wF=total-wB; if(!wF) break; sumB+= i*hist[i];
    const mB=sumB/wB, mF=(sum-sumB)/wF; const between=wB*wF*(mB-mF)*(mB-mF); if(between>max){max=between;thr=i;} }
  const bin=new Uint8Array(W*H); for(let i=0;i<blur.length;i++){ bin[i] = (blur[i]>thr)?1:0; }
  // Close (dilate then erode)
  const dil=(src)=>{ const dst=new Uint8Array(W*H);
    for(let y=1;y<H-1;y++)for(let x=1;x<W-1;x++){ let v=0; for(let dy=-1;dy<=1;dy++)for(let dx=-1;dx<=1;dx++){ if(src[(y+dy)*W+(x+dx)]){v=1;break;} } dst[y*W+x]=v; }
    return dst; };
  const ero=(src)=>{ const dst=new Uint8Array(W*H);
    for(let y=1;y<H-1;y++)for(let x=1;x<W-1;x++){ let v=1; for(let dy=-1;dy<=1;dy++)for(let dx=-1;dx<=1;dx++){ if(!src[(y+dy)*W+(x+dx)]){v=0;break;} } dst[y*W+x]=v; }
    return dst; };
  let m = dil(bin); m = dil(m); m = ero(m);
  // Connected components -> boxes
  const seen=new Uint8Array(W*H); const boxes=[];
  const minA = W*H*0.01, maxA=W*H*0.45;
  for(let y=1;y<H-1;y++)for(let x=1;x<W-1;x++){
    const i=y*W+x; if(!m[i] || seen[i]) continue;
    const q=[i]; seen[i]=1;
    let x0=x,x1=x,y0=y,y1=y, area=0;
    while(q.length){
      const p=q.pop(); const py=(p/W)|0, px=p%W; area++;
      if(px<x0)x0=px; if(px>x1)x1=px; if(py<y0)y0=py; if(py>y1)y1=py;
      const nb=[p-1,p+1,p-W,p+W];
      for(const n of nb){ if(n>0 && n<W*H && m[n] && !seen[n]){ seen[n]=1; q.push(n); } }
    }
    const bw=x1-x0+1, bh=y1-y0+1, ar=bw/bh, A=bw*bh;
    if(A>=minA && A<=maxA && ar>0.6 && ar<1.8){
      const pad=Math.floor(Math.min(bw,bh)*0.08)+6;
      x0=Math.max(0,x0-pad); y0=Math.max(0,y0-pad);
      x1=Math.min(W-1,x1+pad); y1=Math.min(H-1,y1+pad);
      boxes.push([x0,y0,x1,y1]);
    }
  }
  // If single wide band -> split by vertical projection
  if(boxes.length<=1){
    const col=new Float32Array(W);
    for(let x=0;x<W;x++){ let s=0; for(let y=0;y<H;y++){ s+= m[y*W+x]; } col[x]=s; }
    // find valleys
    const gapThr = H*0.04; let start=0; const seg=[];
    for(let x=1;x<W;x++){
      if(col[x]<gapThr && (x-start)>Math.max(40, W*0.12)){ seg.push([start,x]); start=x+1; }
    }
    if((W-start)>Math.max(40, W*0.12)) seg.push([start,W-1]);
    if(seg.length){ boxes.length=0; for(const [a,b] of seg){ boxes.push([a,0,b,H-1]); } }
  }
  if(!boxes.length){ boxes.push([0,0,W-1,H-1]); }
  boxes.sort((a,b)=>a[0]-b[0]);
  const out=[]; for(const [a,b,c,d] of boxes){
    const cw=c-a+1, ch=d-b+1; const cn=document.createElement('canvas'); cn.width=cw; cn.height=ch;
    cn.getContext('2d').drawImage(canvas, a,b,cw,ch, 0,0,cw,ch); out.push(cn);
  }
  return out.slice(0,6);
}
async function __classifyTileCanvas(cnv){
  if(typeof net==='undefined' || !net?.infer || typeof classifier==='undefined' || !classifier?.predictClass) return null;
  const timg=tf.browser.fromPixels(cnv);
  const emb=net.infer(timg,true);
  const res=await classifier.predictClass(emb,3);
  timg.dispose(); emb.dispose();
  if(!res||!res.confidences) return null;
  const lbl=res.label; const score=res.confidences[lbl]||0;
  return {label:lbl, score};
}
function __appendTileThumb(dataURL, text){
  const host=document.getElementById('snapThumbs'); if(!host) return;
  const box=document.createElement('div'); box.style.position='relative'; box.style.width='48px'; box.style.height='48px';
  box.style.border='1px solid #22324a'; box.style.borderRadius='6px'; box.style.overflow='hidden';
  const im=new Image(); im.src=dataURL; im.style.width='100%'; im.style.height='100%'; im.style.objectFit='cover';
  const cap=document.createElement('div'); cap.style.position='absolute'; cap.style.bottom='2px'; cap.style.right='2px';
  cap.style.fontSize='11px'; cap.style.background='rgba(0,0,0,.6)'; cap.style.padding='1px 4px'; cap.style.borderRadius='6px';
  cap.textContent=text||''; box.appendChild(im); box.appendChild(cap); host.prepend(box);
  while(host.children.length>12) host.removeChild(host.lastElementChild);
}
</script>
</body>
</html>
