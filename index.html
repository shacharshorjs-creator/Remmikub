<!doctype html>
<html lang="he" dir="rtl">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>×¨××™×§×•×‘ â€” ××™××•×Ÿ+××©×—×§ (v6.2-ml)</title>
<style>
  :root{--bg:#0d131a;--card:#121a23;--ink:#e8f0ff;--muted:#9bb1c9;--accent:#61dafb;--ok:#2ecc71;--bad:#e74c3c;}
  html,body{margin:0;background:var(--bg);color:var(--ink);font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{max-width:900px;margin:0 auto;padding:16px}
  .pill{display:inline-block;background:#182232;color:var(--ink);padding:6px 10px;border-radius:999px;margin:4px 6px;font-size:13px}
  .btn{background:#243145;color:var(--ink);border:none;border-radius:10px;padding:10px 12px;margin:6px 4px;cursor:pointer}
  .btn.ok{background:#1e7e34} .btn.bad{background:#8e2c2c}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .board{background:var(--card);border-radius:16px;padding:14px;margin:12px 0}
  table{width:100%;border-collapse:collapse}
  th,td{padding:10px;border-bottom:1px solid #1e2a3a;text-align:center}
  .num{font-variant-numeric:tabular-nums}
  .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(120px,1fr));gap:10px}
  .thumb{position:relative;background:#0b0f16;border-radius:12px;overflow:hidden;border:1px solid #233047}
  .thumb img{width:100%;display:block}
  .thumb .cap{position:absolute;bottom:6px;inset-inline:6px;background:rgba(0,0,0,.55);padding:4px 6px;border-radius:8px;font-size:12px}
  .mono{white-space:pre-wrap;font-family:ui-monospace,Menlo,Consolas,monospace;background:#0b0f16;border:1px solid #1f2b3c;border-radius:12px;padding:10px}
  input[type=number]{background:#0b0f16;border:1px solid #223047;border-radius:8px;color:var(--ink);padding:8px 10px;width:80px;text-align:center}
  .camera{display:inline-block;border:1px dashed #445a77;border-radius:10px;padding:10px 12px}
</style>
</head>
<body>
<div class="wrap">
  <div class="row">
    <span class="pill">v6.2-ml</span>
    <span class="pill" id="tfBadge">TF: init</span>
    <span class="pill" id="modelBadge">model: init</span>
  </div>

  <div class="board">
    <h3 style="margin-top:0">×œ×•×— ×”×•×‘×œ×”</h3>
    <table id="scoreTbl">
      <thead><tr><th>#</th><th>×©×</th><th>× ×§×•×“×•×ª</th><th>×¤×¢×•×œ×•×ª</th></tr></thead>
      <tbody id="playersTbody"></tbody>
    </table>
  </div>

  <div class="board">
    <h3 style="margin-top:0">×‘×—×™×¨×ª ××©×ª×ª×¤×™× (×¢×“ 4)</h3>
    <div class="row">
      <input id="p1" placeholder="×©×—×§×Ÿ 1" class="btn" style="flex:1"/>
      <input id="p2" placeholder="×©×—×§×Ÿ 2" class="btn" style="flex:1"/>
    </div>
    <div class="row">
      <input id="p3" placeholder="×©×—×§×Ÿ 3" class="btn" style="flex:1"/>
      <input id="p4" placeholder="×©×—×§×Ÿ 4" class="btn" style="flex:1"/>
    </div>
    <button class="btn" id="startGame">×”×ª×—×œ ××©×—×§</button>
  </div>

  <div class="board">
    <h3 style="margin:0 0 8px 0">×–×™×”×•×™ ××—×¨×•×Ÿ</h3>
    <div id="detectLine" class="mono">â€”</div>
    <div id="thumbs" class="grid" style="margin-top:10px"></div>
  </div>

  <div class="board">
    <h3 style="margin:0 0 10px 0">(CPU) ××™××•×Ÿ ××•×“×œ ×–×™×”×•×™</h3>
    <div class="row">
      <label>×‘×—×¨/×™ ××—×œ×§×” (××¡×¤×¨):</label>
      <input type="number" id="classIdx" value="1" min="0" max="13"/>
      <button class="btn" id="snapBtn">×¦×™×œ×•× ××”××¦×œ××”</button>
      <label class="camera">
        <input id="fileInput" type="file" accept="image/*" multiple style="display:none">
        <span class="btn">×”×•×¡×£ ×××’'×™×¨ (×’×œ×¨×™×”)</span>
      </label>
      <button class="btn" id="clearBtn">× ×§×” ×”×›×œ</button>
    </div>
    <div class="row">
      <button class="btn" id="saveLocal">×©××•×¨ ××•×“×œ</button>
      <button class="btn" id="restoreLocal">×©×—×–×¨ ××•×“×œ</button>
      <button class="btn" id="exportJson">×™×™×¦× JSON</button>
      <input type="file" id="importJson" accept="application/json" style="display:none">
      <button class="btn" id="importBtn">×™×™×‘× JSON</button>
    </div>
    <div class="mono" id="log"></div>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@2.1.0"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/knn-classifier@1.2.2"></script>
<script>
// ------- minimal game state (unchanged layout) -------
const players = [
  {name:'×©×—×¨', score:0},
  {name:'××™×ª×™', score:0},
  {name:'×©×œ×•×©', score:0},
  {name:'××¨×‘×¢', score:0},
];
function renderPlayers(){
  const tb = document.getElementById('playersTbody');
  tb.innerHTML = '';
  players.forEach((p,i)=>{
    const tr = document.createElement('tr');
    tr.innerHTML = \`
      <td class="num">\${i+1}</td>
      <td>\${p.name}</td>
      <td class="num" id="score-\${i}">\${p.score}</td>
      <td>
        <button class="btn bad" data-i="\${i}" data-d="-10">10-</button>
        <button class="btn ok"  data-i="\${i}" data-d="10">10+</button>
      </td>\`;
    tb.appendChild(tr);
  });
  tb.querySelectorAll('button').forEach(b=>b.onclick = e=>{
    const i = +b.dataset.i, d = +b.dataset.d;
    players[i].score += d;
    document.getElementById('score-'+i).textContent = players[i].score;
  });
}
renderPlayers();
document.getElementById('startGame').onclick = ()=>{
  ['p1','p2','p3','p4'].forEach((id,i)=>{
    const v = document.getElementById(id).value.trim();
    if(v) players[i].name = v;
  });
  renderPlayers();
};

// ---------- TF / MobileNet / KNN ----------
let net, knn, ready=false;
(async ()=>{
  try{
    document.getElementById('tfBadge').textContent = 'TF: '+tf.getBackend();
  }catch(e){}
  knn = knnClassifier.create();
  net = await mobilenet.load({version:2,alpha:1.0});
  ready = true;
  document.getElementById('modelBadge').textContent = 'model: ready';
  log('models loaded');
  autoRestoreLocal();
})();

function embedFrom(img){
  // get conv embeddings (1024)
  return net.infer(img, true);
}

async function addExampleFromImage(img, label){
  tf.tidy(()=>{
    const emb = embedFrom(img);
    knn.addExample(emb, label);
  });
}

// ---------- segmentation: improved connected-components on gradient ----------
function segmentTiles(image){
  const maxTiles = 6; // safety
  const w = image.naturalWidth || image.videoWidth || image.width;
  const h = image.naturalHeight || image.videoHeight || image.height;
  const can = document.createElement('canvas'); can.width=w; can.height=h;
  const ctx = can.getContext('2d'); ctx.drawImage(image,0,0,w,h);
  const {data} = ctx.getImageData(0,0,w,h);
  // grayscale + Sobel
  const gray = new Float32Array(w*h);
  for(let y=0, i=0, j=0;y<h;y++) for(let x=0;x<w;x++, i+=4, j++){
    gray[j] = (data[i]*0.299 + data[i+1]*0.587 + data[i+2]*0.114);
  }
  const gx = new Float32Array(w*h), gy = new Float32Array(w*h), mag = new Float32Array(w*h);
  const sx = [-1,0,1,-2,0,2,-1,0,1], sy=[-1,-2,-1,0,0,0,1,2,1];
  for(let y=1;y<h-1;y++){
    for(let x=1;x<w-1;x++){
      let ix = 0, iy = 0, k=0;
      for(let yy=-1; yy<=1; yy++){
        const ry = y+yy;
        for(let xx=-1; xx<=1; xx++, k++){
          const rx = x+xx;
          const v = gray[ry*w+rx];
          ix += v * sx[k]; iy += v * sy[k];
        }
      }
      const m = Math.hypot(ix,iy);
      mag[y*w+x] = m;
    }
  }
  // threshold at 75th percentile of gradient
  const sample = []; for(let i=0;i<mag.length;i+=16) sample.push(mag[i]);
  sample.sort((a,b)=>a-b);
  const thr = sample[Math.floor(sample.length*0.75)]||40;
  const bin = new Uint8Array(w*h);
  for(let i=0;i<mag.length;i++) bin[i] = mag[i] > thr ? 1 : 0;
  // dilate then erode (close) x2
  const K=[
    [0,1,0],
    [1,1,1],
    [0,1,0]
  ];
  const dil = (src)=>{
    const dst = new Uint8Array(w*h);
    for(let y=1;y<h-1;y++) for(let x=1;x<w-1;x++){
      let on=0;
      if(src[(y-1)*w+x]) on=1;
      else if(src[(y+1)*w+x]) on=1;
      else if(src[y*w+x-1]) on=1;
      else if(src[y*w+x+1]) on=1;
      else if(src[y*w+x]) on=1;
      dst[y*w+x]=on;
    }
    return dst;
  };
  const ero = (src)=>{
    const dst = new Uint8Array(w*h);
    for(let y=1;y<h-1;y++) for(let x=1;x<w-1;x++){
      let ok= src[(y-1)*w+x] && src[(y+1)*w+x] && src[y*w+x-1] && src[y*w+x+1] && src[y*w+x];
      dst[y*w+x]= ok?1:0;
    }
    return dst;
  };
  let m1 = dil(bin); m1 = dil(m1); m1 = ero(m1);

  // connected components (4-neigh)
  const visited = new Uint8Array(w*h);
  const boxes = [];
  const qx = new Int32Array(w*h); const qy = new Int32Array(w*h);
  for(let y=1;y<h-1;y++){
    for(let x=1;x<w-1;x++){
      const idx = y*w+x;
      if(m1[idx] && !visited[idx]){
        let head=0, tail=0; qx[tail]=x; qy[tail]=y; tail++; visited[idx]=1;
        let minx=x, miny=y, maxx=x, maxy=y, count=0;
        while(head<tail){
          const cx=qx[head], cy=qy[head]; head++; count++;
          const nbr=[[1,0],[-1,0],[0,1],[0,-1]];
          for(const [dx,dy] of nbr){
            const nx=cx+dx, ny=cy+dy, nidx=ny*w+nx;
            if(nx>0 && nx<w-1 && ny>0 && ny<h-1 && m1[nidx] && !visited[nidx]){
              visited[nidx]=1; qx[tail]=nx; qy[tail]=ny; tail++;
              if(nx<minx)minx=nx; if(nx>maxx)maxx=nx; if(ny<miny)miny=ny; if(ny>maxy)maxy=ny;
            }
          }
        }
        const bw = maxx-minx+1, bh = maxy-miny+1;
        const area = bw*bh;
        const imgArea = w*h;
        const ar = bw/bh;
        if(area > imgArea*0.01 && area < imgArea*0.4 && ar>0.6 && ar<1.8){
          // expand a bit
          const pad = Math.floor(Math.min(bw,bh)*0.1)+6;
          minx=Math.max(0,minx-pad); miny=Math.max(0,miny-pad);
          maxx=Math.min(w-1,maxx+pad); maxy=Math.min(h-1,maxy+pad);
          boxes.push([minx,miny,maxx,maxy]);
        }
      }
    }
  }
  // NMS to avoid duplicates
  const iou = (a,b)=>{
    const [ax1,ay1,ax2,ay2]=a, [bx1,by1,bx2,by2]=b;
    const x1=Math.max(ax1,bx1), y1=Math.max(ay1,by1);
    const x2=Math.min(ax2,bx2), y2=Math.min(ay2,by2);
    const inter=Math.max(0,x2-x1)*Math.max(0,y2-y1);
    const area1=(ax2-ax1)*(ay2-ay1), area2=(bx2-bx1)*(by2-by1);
    return inter/(area1+area2-inter+1e-6);
  };
  boxes.sort((a,b)=> (b[2]-b[0])*(b[3]-b[1]) - (a[2]-a[0])*(a[3]-a[1]));
  const pick=[];
  boxes.forEach(b=>{
    if(pick.every(p=>iou(p,b)<0.25)) pick.push(b);
  });
  return pick.slice(0,maxTiles).map(([x1,y1,x2,y2])=>{
    const cw=x2-x1, ch=y2-y1;
    const c=document.createElement('canvas'); c.width=cw; c.height=ch;
    c.getContext('2d').drawImage(image,x1,y1,cw,ch,0,0,cw,ch);
    return c;
  });
}

function log(t){ const el = document.getElementById('log'); el.textContent += (t+'\n'); el.scrollTop=1e9; }

// ---------- capture / gallery ----------
const thumbs = document.getElementById('thumbs');
function addThumb(canvas, label, prob){
  const url = canvas.toDataURL('image/jpeg',0.9);
  const div = document.createElement('div'); div.className='thumb';
  const im = new Image(); im.src=url;
  const cap = document.createElement('div'); cap.className='cap';
  cap.textContent = (label!=null ? (label+' â€¢ '+Math.round(prob*100)+'%') : 'â€”');
  div.appendChild(im); div.appendChild(cap);
  thumbs.prepend(div);
}

async function handleImageInput(imgEl, forTraining=false){
  if(!ready){ alert('TF not ready yet'); return; }
  const tiles = segmentTiles(imgEl);
  if(tiles.length===0){
    // fallback: whole image
    tiles.push(imgEl);
  }
  let texts=[];
  for(const tile of tiles){
    let label=null, prob=0;
    if(forTraining){
      const cls = document.getElementById('classIdx').value;
      await addExampleFromImage(tile, cls);
      label = cls; prob = 1;
    }else if(knn.getNumClasses() > 0){
      const res = await tf.tidy(()=>{
        const emb = embedFrom(tile);
        return knn.predictClass(emb);
      });
      label = res.label;
      prob = res.confidences[res.label] || 0;
    }
    addThumb(tile, label, prob);
    if(label!=null) texts.push(label);
  }
  if(texts.length){
    document.getElementById('detectLine').textContent = '×–×•×”×• ×§×•×‘×™×•×ª: '+texts.join(', ');
  }else{
    document.getElementById('detectLine').textContent = '×œ× ×–×•×”×• ×§×•×‘×™×•×ª';
  }
}

// camera input (uses file input with capture)
document.getElementById('snapBtn').onclick = ()=>{
  const inp = document.createElement('input');
  inp.type='file'; inp.accept='image/*'; inp.capture='environment';
  inp.onchange = async e=>{
    const f = inp.files[0]; if(!f) return;
    const url = URL.createObjectURL(f);
    const im = new Image(); im.onload = ()=>{handleImageInput(im, true); URL.revokeObjectURL(url);}; im.src = url;
  };
  inp.click();
};

document.getElementById('fileInput').onchange = e=>{
  const files = e.target.files;
  for(const f of files){
    const url = URL.createObjectURL(f);
    const im = new Image(); im.onload = ()=>{handleImageInput(im, true); URL.revokeObjectURL(url);}; im.src = url;
  }
};

// ---------- Save/Restore (localStorage + JSON) ----------
function datasetToJSON(){
  const ds = knn.getClassifierDataset();
  const obj = {};
  Object.keys(ds).forEach(k=>{
    const t = ds[k];            // tf.Tensor2D
    const data = Array.from(t.dataSync());
    obj[k] = {data, shape: t.shape}; // keep exact shape per class
  });
  return obj;
}
function jsonToDataset(json){
  const obj = json;
  const ds = {};
  Object.keys(obj).forEach(k=>{
    const {data, shape} = obj[k];
    ds[k] = tf.tensor2d(data, shape, 'float32');
  });
  knn.setClassifierDataset(ds);
}
document.getElementById('saveLocal').onclick = ()=>{
  const obj = datasetToJSON();
  localStorage.setItem('rummikub_knn_v6', JSON.stringify(obj));
  log('ğŸ’¾ × ×©××¨ ××§×•××™×ª â€¢ '+(new Blob([JSON.stringify(obj)]).size/1024).toFixed(1)+' KB');
};
function autoRestoreLocal(){
  try{
    const s = localStorage.getItem('rummikub_knn_v6');
    if(s){
      const obj = JSON.parse(s);
      jsonToDataset(obj);
      log('ğŸ“¦ ×©×•×—×–×¨ ××§×•××™×ª');
    }
  }catch(e){ log('ERR restore local: '+e); }
}
document.getElementById('restoreLocal').onclick = autoRestoreLocal;

document.getElementById('exportJson').onclick = ()=>{
  const obj = datasetToJSON();
  const blob = new Blob([JSON.stringify(obj)], {type:'application/json'});
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'rummikub_knn_v6.json';
  a.click();
  URL.revokeObjectURL(a.href);
};
document.getElementById('importBtn').onclick = ()=> document.getElementById('importJson').click();
document.getElementById('importJson').onchange = e=>{
  const f = e.target.files[0]; if(!f) return;
  const fr = new FileReader();
  fr.onload = ()=>{
    try{
      const obj = JSON.parse(fr.result);
      jsonToDataset(obj);
      log('âœ… model restored from JSON');
    }catch(err){ alert('×™×™×‘×•× × ×›×©×œ'); log('ERR import: '+err); }
  };
  fr.readAsText(f);
};
document.getElementById('clearBtn').onclick = ()=>{
  knn = knnClassifier.create();
  localStorage.removeItem('rummikub_knn_v6');
  thumbs.innerHTML='';
  document.getElementById('detectLine').textContent = 'â€”';
  log('ğŸ—‘ï¸ ××™×¤×•×¡ ××•×“×œ');
};
</script>
</body>
</html>
