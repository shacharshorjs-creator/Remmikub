<!doctype html>
<html lang="he" dir="rtl">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <title>index • v6.12-ml</title>
  <style>
    body{background:#0e1726;color:#e6edf3;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,"Apple Color Emoji","Segoe UI Emoji";margin:0;padding:16px}
    .note{background:#0b1220;border:1px solid #1d283a;border-radius:12px;padding:14px;margin:10px 0;font-size:14px;line-height:1.45}
    .ok{color:#84d85b}.warn{color:#ffd866}
    code{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,Monaco,monospace;background:#0a1322;padding:2px 6px;border-radius:6px}
    .badge{display:inline-block;background:#132033;border:1px solid #20324d;border-radius:999px;padding:6px 10px;margin:2px 6px 0 0;font-size:12px}
  </style>
</head>
<body>
  <div class="badge">v6.12-ml</div>
  <div class="badge">model: init</div>
  <div class="badge">TF: init</div>

  <div class="note">
    קובץ זה הוא <b>תוספת הזרקה</b> בלבד: הוא לא משנה את ה‑UI שלך ולא את זרימת המשחק. 
    הוא מוסיף/מחליף את פונקציית חיתוך הקוביות ומעדכן את מספר הגרסה ל‑<b>v6.12‑ml</b>.
    אפשר להעלות אותו כ‑<code>index</code> והוא יעבוד עם ה‑DOM הקיים.
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>

  <script>
  // ===== version bump helper (non-intrusive) =====
  (function(){
    window.APP_VERSION = 'v6.12-ml';
    // נסה לעדכן באדג'ים קיימים אם יש
    try {
      const chips = Array.from(document.querySelectorAll('*'))
        .filter(el => /v\d+\.\d+.*-ml/.test(el.textContent||''));
      chips.forEach(el => el.textContent = window.APP_VERSION);
    } catch(e){}
  })();
  </script>

  <script>
  // ===== smart multi-tile crop v6.12 (drop-in) =====
  window.sliceTilesFromImage = async function sliceTilesFromImage(imgEl) {
    const TILE_MIN_AREA_RATIO = 0.0045; // 0.45%
    const TILE_MAX_AREA_RATIO = 0.28;
    const AR_MIN = 0.62, AR_MAX = 0.92;
    const PAD = 0.06;

    const rgb = tf.tidy(()=>tf.browser.fromPixels(imgEl).toFloat().div(255));
    const [H,W] = rgb.shape.slice(0,2);
    const minArea = H*W*TILE_MIN_AREA_RATIO;
    const maxArea = H*W*TILE_MAX_AREA_RATIO;

    const gray = tf.tidy(()=>{
      const [r,g,b] = tf.split(rgb,3,2);
      const y = r.mul(0.2989).add(g.mul(0.587)).add(b.mul(0.114));
      const y4 = y.reshape([1,H,W,1]);
      const k = tf.tensor4d([1,2,1,2,4,2,1,2,1],[3,3,1,1]).div(16);
      return y4.conv2d(k,1,'same').squeeze();
    });

    const edge = tf.tidy(()=>{
      const y4 = gray.reshape([1,H,W,1]);
      const sob = tf.image.sobelEdges(y4);
      const gx = sob.slice([0,0,0,0,0],[1,H,W,1,1]).squeeze();
      const gy = sob.slice([0,0,0,0,1],[1,H,W,1,1]).squeeze();
      const mag = gx.square().add(gy.square()).sqrt();
      const mean = mag.mean();
      const std = mag.sub(mean).square().mean().sqrt();
      const thr = mean.add(std.mul(0.35)); // קצת רגיש יותר
      return mag.greater(thr).toInt();
    });

    function morph(bin,iters,type){
      return tf.tidy(()=>{
        let t = bin;
        for(let i=0;i<iters;i++){
          const k = tf.ones([3,3,1]);
          const x = t.reshape([1,H,W,1]).toFloat();
          const y = (type==='dilate') ?
            x.conv2d(k,1,'same').greater(0).toInt() :
            x.conv2d(k,1,'same').greater(7).toInt();
          t.dispose(); t = y.squeeze().toInt();
        }
        return t;
      });
    }
    const closed = morph(morph(edge,1,'dilate'),1,'erode');

    async function computeBoxes(){
      const arr = await closed.data();
      const visited = new Uint8Array(arr.length);
      const w=W,h=H;
      const res=[], stack=[];
      for(let y=1;y<h-1;y++){
        for(let x=1;x<w-1;x++){
          const idx=y*w+x;
          if(arr[idx]!==1 || visited[idx]) continue;
          let minx=x,maxx=x,miny=y,maxy=y, count=0;
          stack.length=0; stack.push(idx); visited[idx]=1;
          while(stack.length){
            const i = stack.pop();
            const cy = Math.floor(i/w), cx = i - cy*w;
            count++;
            if(cx<minx)minx=cx; if(cx>maxx)maxx=cx;
            if(cy<miny)miny=cy; if(cy>maxy)maxy=cy;
            for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++){
              if(!dx&&!dy) continue;
              const nx=cx+dx, ny=cy+dy;
              if(nx<=0||ny<=0||nx>=w-1||ny>=h-1) continue;
              const ni=ny*w+nx;
              if(arr[ni]===1 && !visited[ni]){ visited[ni]=1; stack.push(ni); }
            }
          }
          const bw=maxx-minx+1, bh=maxy-miny+1, area=bw*bh, ar=bw/bh;
          if(area>=minArea && area<=maxArea && ar>=AR_MIN && ar<=AR_MAX){
            const padX=Math.round(bw*PAD), padY=Math.round(bh*PAD);
            const x0=Math.max(0,minx-padX), y0=Math.max(0,miny-padY);
            const x1=Math.min(W-1,maxx+padX), y1=Math.min(H-1,maxy+padY);
            res.push({x:x0,y:y0,w:x1-x0+1,h:y1-y0+1, area:(x1-x0+1)*(y1-y0+1)});
          }
        }
      }
      // non-max suppression קל
      res.sort((a,b)=>a.x-b.x);
      const out=[];
      for(const A of res){
        let keep=true;
        for(const B of out){
          const xx0=Math.max(A.x,B.x), yy0=Math.max(A.y,B.y);
          const xx1=Math.min(A.x+A.w,B.x+B.w), yy1=Math.min(A.y+A.h,B.y+B.h);
          const inter=Math.max(0,xx1-xx0)*Math.max(0,yy1-yy0);
          const iou = inter/Math.min(A.area,B.area);
          if(iou>0.5){ keep=false; break; }
        }
        if(keep) out.push(A);
      }
      // מיון שורה-שורה
      out.sort((a,b)=> (a.y+a.h*0.5) - (b.y+b.h*0.5) || a.x-b.x);
      return out;
    }

    const boxes = await computeBoxes();

    const crops=[];
    const cnv=document.createElement('canvas');
    const ctx=cnv.getContext('2d');
    cnv.width=W; cnv.height=H;
    ctx.drawImage(imgEl,0,0,W,H);
    for(const b of boxes){
      const c=document.createElement('canvas');
      c.width=b.w; c.height=b.h;
      c.getContext('2d').drawImage(cnv,b.x,b.y,b.w,b.h,0,0,b.w,b.h);
      crops.push({dataURL:c.toDataURL('image/jpeg',0.9), box:b});
    }

    tf.dispose([rgb,gray,edge,closed]);
    return crops;
  };
  // optional helper to classify and render thumbnails without UI changes
  window.__applyCropsToThumbnails = async function(crops, onThumb){
    (crops||[]).forEach(c => { if(typeof onThumb==='function') onThumb(c.dataURL); });
  };
  // ===== end smart crop v6.12 =====
  </script>

</body>
</html>