<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="manifest" href="manifest.webmanifest">
<meta name="theme-color" content="#0e1220">
<title>×¨××™×§×•×‘ â€“ × ×§×•×“×•×ª (v2.4-ml)</title>
<style>
  :root{
    --bg:#0e1220;--card:#151a2b;--ink:#eaf1ff;--muted:#9fb0c9;
    --line:rgba(255,255,255,.14);--accent:#63c9ff;--accent2:#8affc1;--chip:#0b1325
  }
  html,body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  .container{width:min(980px,94vw);margin:0 auto;padding:90px 0 28px}
  .card{background:var(--card);border:1px solid var(--line);border-radius:16px;padding:16px}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  label{display:block;font-weight:700;margin-bottom:6px}
  input[type=text]{width:100%;background:#0b152a;color:#fff;border:2px solid var(--line);border-radius:12px;padding:12px 14px}
  button{cursor:pointer;border:none;border-radius:12px;padding:10px 14px;background:#1c2741;color:#fff}
  .accent{background:linear-gradient(135deg,#63c9ff,#8affc1);color:#0b1320;font-weight:900}
  .ghost{background:transparent;border:1px dashed var(--line)}
  .danger{background:#3a1c1c;color:#ffd9d9;border:1px solid #5a2a2a}
  .grid{display:grid;gap:12px;grid-template-columns:repeat(auto-fit,minmax(260px,1fr))}
  .hidden{display:none}
  .leader{display:flex;gap:10px;flex-wrap:wrap}
  .chip{background:var(--chip);border:1px solid var(--line);border-radius:12px;padding:10px 12px;display:flex;gap:10px;align-items:center}
  .rank{font-weight:900;width:28px;height:28px;display:grid;place-items:center;border-radius:99px;background:#0d1a2e;border:1px solid rgba(100,200,255,.45)}
  .pill{padding:6px 10px;border-radius:999px;background:#0b172d;border:1px solid var(--line)}
  .controls{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
  .numbox{width:90px;background:#0b152a;color:#fff;border:1px solid var(--line);border-radius:10px;padding:8px 10px}
  .btn-upload{background:#0f1a30;border:1px solid rgba(99,201,255,.45)}
  .btn-upload::before{content:"ğŸ–¼ï¸";margin-inline-end:6px}
  .btn-plus{background:#0f2e1a;border:1px solid rgba(138,255,193,.45)}
  .btn-plus::before{content:"â•";margin-inline-end:6px}
  .parsed{font-size:13px;color:var(--muted);margin-top:6px}
  .appbar{position:fixed;inset:0 0 auto 0;height:72px;background:rgba(8,12,24,.7);backdrop-filter:blur(10px);
          border-bottom:1px solid var(--line);z-index:10;display:flex;align-items:center}
  .appbar-inner{width:min(980px,94vw);margin:0 auto;display:flex;align-items:center;gap:12px;justify-content:space-between}
  .title{font-weight:800;letter-spacing:.2px}
  .ver{font-size:12px;padding:6px 10px;border-radius:999px;background:#0a1a2c;border:1px solid rgba(99,201,255,.4)}
  .actions{display:flex;gap:8px;align-items:center}
  .divider{height:1px;background:linear-gradient(90deg,transparent,var(--line),transparent);margin:14px 0;border:none}
  .switch{display:inline-flex;align-items:center;gap:6px;padding:4px 10px;border:1px solid var(--line);border-radius:999px;background:#0a1426;font-size:12px}
  .slider-wrap{display:flex;align-items:center;gap:8px}
  input[type=range]{width:160px}
</style>
</head>
<body>
<div class="appbar">
  <div class="appbar-inner">
    <div class="row">
      <div class="title">×¨××™×§×•×‘ â€“ × ×™×”×•×œ × ×§×•×“×•×ª</div>
      <div class="ver" aria-label="version">v2.4-ml</div>
    </div>
    <div class="actions">
      <div class="switch">
        <label for="ignoreColor">×”×ª×¢×œ× ××¦×‘×¢</label>
        <input id="ignoreColor" type="checkbox" checked>
      </div>
      <div class="switch slider-wrap">
        <label for="confThresh">×¡×£ ×‘×™×˜×—×•×Ÿ</label>
        <input id="confThresh" type="range" min="0.3" max="0.9" step="0.05" value="0.6">
        <span id="confVal">0.60</span>
      </div>
      <button id="resetBtn" class="danger">××™×¤×•×¡ × ×§×•×“×•×ª</button>
      <button id="toggleTrainer" class="accent">××•×“×œ ×–×™×”×•×™ (××™××•×Ÿ ×¤×¢×™×œ)</button>
    </div>
  </div>
</div>

<div class="container">
  <section id="s1" class="card">
    <h2 style="margin-top:0">×‘×—×™×¨×ª ××©×ª×ª×¤×™× (×¢×“ 4)</h2>
    <div class="grid" style="margin-top:8px">
      <div><label for="n0">×©×—×§×Ÿ/×™×ª 1</label><input id="n0" type="text" placeholder="×œ×“×•×’××”: ×©×—×¨"></div>
      <div><label for="n1">×©×—×§×Ÿ/×™×ª 2</label><input id="n1" type="text" placeholder="×œ×“×•×’××”: ×“× ×”"></div>
      <div><label for="n2">×©×—×§×Ÿ/×™×ª 3</label><input id="n2" type="text" placeholder="××•×¤×¦×™×•× ×œ×™"></div>
      <div><label for="n3">×©×—×§×Ÿ/×™×ª 4</label><input id="n3" type="text" placeholder="××•×¤×¦×™×•× ×œ×™"></div>
    </div>
    <div class="row" style="margin-top:12px;justify-content:space-between">
      <button class="accent" id="startBtn">×”×ª×—×œ ××©×—×§</button>
      <span style="font-size:12px;color:#9fb0c9">×’×¨×¡×ª ML ×¢× ××™××•×Ÿ ××•×‘× ×”</span>
    </div>
  </section>

  <section id="s2" class="card hidden">
    <div class="row" style="justify-content:space-between">
      <h2 style="margin:0">×œ×•×— ×”×•×‘×œ×”</h2>
      <button id="backBtn" class="ghost">â†© ×—×–×¨×” ×œ×©××•×ª</button>
    </div>
    <div id="board" class="leader" style="margin-top:10px"></div>
    <hr class="divider">
    <div id="panels" class="grid"></div>
  </section>

  <!-- Trainer open by default -->
  <section id="trainer" class="card">
    <h2 style="margin-top:0">××•×“×œ ×–×™×”×•×™ â€“ ××™××•×Ÿ ×¢×œ ×”××›×©×™×¨</h2>
    <div class="row">
      <div>
        <label>×‘×—×¨/×™ ××—×œ×§×”</label>
        <select id="cls">
          <option value="none">×œ×œ× / ×’×³×•×§×¨</option>
          <option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option>
          <option value="5">5</option><option value="6">6</option><option value="7">7</option><option value="8">8</option>
          <option value="9">9</option><option value="10">10</option><option value="11">11</option><option value="12">12</option><option value="13">13</option>
        </select>
      </div>
      <div class="row" style="gap:6px">
        <button id="addFromGallery" class="btn-upload"> ×”×•×¡×£ ××’×–×™×¨</button>
        <input id="filePick" type="file" accept="image/*" class="hidden" multiple>
        <button id="captureOne" class="btn-plus"> ×”×•×¡×£ ××”××¦×œ××”</button>
      </div>
      <div class="row">
        <button id="saveModel" class="ghost">×©××•×¨ ××•×“×œ</button>
        <button id="loadModel" class="ghost">×˜×¢×Ÿ ××•×“×œ</button>
        <button id="exportModel" class="ghost">×™×™×¦× JSON</button>
        <input id="importFile" type="file" accept="application/json" class="hidden">
        <button id="importModel" class="ghost">×™×™×‘× JSON</button>
        <span id="status" class="ver">××™×Ÿ ××•×“×œ</span>
      </div>
    </div>
  </section>
</div>

<!-- TFJS libs -->
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@2.1.0"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/knn-classifier@1.2.2"></script>
<!-- OCR fallback -->
<script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>
<!-- OpenCV for segmentation -->
<script async src="https://docs.opencv.org/4.8.0/opencv.js"></script>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const KEY = 'rummi_pwa_state_v2.4-ml';
  const MODEL_KEY = 'rummi_knn_v2.4-ml';
  let state = { players: [] };
  try { const raw = localStorage.getItem(KEY); if (raw) state = JSON.parse(raw); } catch (e) { console.warn(e); }

  const settings = { ignoreColor: true, conf: 0.6 };

  const $ = s => document.querySelector(s);
  const statusEl = $('#status');
  const confSlider = document.getElementById('confThresh');
  const confVal = document.getElementById('confVal');
  const ignoreCb = document.getElementById('ignoreColor');

  // Reflect UI
  if (confSlider && confVal) {
    confVal.textContent = Number(confSlider.value).toFixed(2);
    confSlider.addEventListener('input', (e)=>{ settings.conf = parseFloat(e.target.value); confVal.textContent = settings.conf.toFixed(2); });
  }
  if (ignoreCb) ignoreCb.addEventListener('change', (e)=> settings.ignoreColor = e.target.checked);

  function save() { try { localStorage.setItem(KEY, JSON.stringify(state)); } catch (e) { console.warn(e); } }
  function val(sel) { const e=$(sel); return e? e.value.trim() : ""; }

  // ===== TFJS + KNN =====
  const classifier = knnClassifier.create();
  let mobilenetModel = null;
  async function loadEmbedder() {
    if (!mobilenetModel) { mobilenetModel = await mobilenet.load({version:2, alpha:1.0}); }
    if(statusEl) statusEl.textContent = 'MobileNet + KNN';
  }
  loadEmbedder();

  function toGray3(t) {
    const H = t.shape[0], W = t.shape[1];
    const r = t.slice([0,0,0],[H,W,1]);
    const g = t.slice([0,0,1],[H,W,1]);
    const b = t.slice([0,0,2],[H,W,1]);
    const gray = r.mul(0.299).add(g.mul(0.587)).add(b.mul(0.114));
    return tf.concat([gray,gray,gray], 2);
  }
  function preprocess(img) {
    let t = tf.browser.fromPixels(img).toFloat();
    if (settings.ignoreColor) t = toGray3(t);
    t = tf.image.resizeBilinear(t, [224,224]);
    const offset = tf.scalar(127.5);
    const norm = t.sub(offset).div(offset);
    return norm.expandDims(0);
  }
  async function addExample(imgOrCanvas, label) {
    const inp = preprocess(imgOrCanvas);
    const logits = mobilenetModel.infer(inp, 'conv_preds');
    classifier.addExample(logits, label);
    tf.dispose([inp, logits]);
  }
  async function predictClass(imgOrCanvas) {
    if (classifier.getNumClasses()===0) return {label:'none', confidences:{none:1}};
    const inp = preprocess(imgOrCanvas);
    const logits = mobilenetModel.infer(inp, 'conv_preds');
    const res = await classifier.predictClass(logits);
    tf.dispose([inp, logits]);
    return res;
  }

  function saveKNN() {
    const dataset = classifier.getClassifierDataset();
    const obj = {}
    Object.keys(dataset).forEach(k=> obj[k] = Array.from(dataset[k].dataSync()));
    localStorage.setItem(MODEL_KEY, JSON.stringify(obj));
    if(statusEl) statusEl.textContent = '××•×“×œ × ×©××¨';
  }
  function loadKNN() {
    const raw = localStorage.getItem(MODEL_KEY);
    if(!raw) return false;
    const obj = JSON.parse(raw);
    const tensorObj = {}
    Object.keys(obj).forEach(k=> tensorObj[k] = tf.tensor(obj[k], [obj[k].length/1001, 1001]));
    classifier.setClassifierDataset(tensorObj);
    if(statusEl) statusEl.textContent = '××•×“×œ × ×˜×¢×Ÿ ('+classifier.getNumClasses()+' ××—×œ×§×•×ª)';
    return true;
  }
  function exportKNN() {
    const dataset = classifier.getClassifierDataset();
    const obj = {}
    Object.keys(dataset).forEach(k=> obj[k] = Array.from(dataset[k].dataSync()));
    const blob = new Blob([JSON.stringify(obj)], {type:'application/json'});
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = 'rummi_knn_v2.4-ml.json';
    a.click();
  }
  async function importKNN(file) {
    const text = await file.text();
    const obj = JSON.parse(text);
    const tensorObj = {}
    Object.keys(obj).forEach(k=> tensorObj[k] = tf.tensor(obj[k], [obj[k].length/1001, 1001]));
    classifier.setClassifierDataset(tensorObj);
    if(statusEl) statusEl.textContent = '××•×“×œ ×™×•×‘× ('+classifier.getNumClasses()+' ××—×œ×§×•×ª)';
  }

  // ===== OpenCV segmentation (simple and robust) =====
  async function ensureCvReady(){
    return new Promise((resolve,reject)=>{
      if (typeof cv !== 'undefined' && cv.Mat) return resolve();
      const t = setInterval(()=>{ if (typeof cv !== 'undefined' && cv.Mat){ clearInterval(t); resolve(); } }, 50);
      setTimeout(()=>{ clearInterval(t); reject(new Error('OpenCV ×œ× × ×˜×¢×Ÿ')); }, 8000);
    });
  }
  async function segmentTiles(imageBitmap){
    await ensureCvReady();
    const maxSide = 1400;
    const scale = Math.min(maxSide/imageBitmap.width, maxSide/imageBitmap.height, 1);
    const w = Math.round(imageBitmap.width*scale), h = Math.round(imageBitmap.height*scale);
    const cvs = document.createElement('canvas'); cvs.width=w; cvs.height=h;
    const ctx = cvs.getContext('2d'); ctx.drawImage(imageBitmap,0,0,w,h);
    let src = cv.imread(cvs);
    let gray = new cv.Mat(); cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
    let blur = new cv.Mat(); cv.GaussianBlur(gray, blur, new cv.Size(5,5), 0);
    let bin = new cv.Mat(); cv.adaptiveThreshold(blur, bin, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 35, 7);
    let contours = new cv.MatVector(), hierarchy = new cv.Mat();
    cv.findContours(bin, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);
    const tiles = [];
    for (let i = 0; i < contours.size(); i++){
      const rect = cv.boundingRect(contours.get(i));
      const ar = rect.width/rect.height;
      const area = rect.width*rect.height;
      if (area> (w*h*0.012) && ar>0.5 && ar<0.98){
        const pad = Math.round(rect.height*0.08);
        const x = Math.max(0, rect.x+pad), y = Math.max(0, rect.y+pad);
        const ch = Math.min(h-y, Math.round(rect.height*0.6));
        const cw = Math.min(w-x, rect.width-pad*2);
        const c = document.createElement('canvas'); c.width=cw; c.height=ch;
        c.getContext('2d').drawImage(cvs, x, y, cw, ch, 0, 0, cw, ch);
        tiles.push({canvas:c, rect});
      }
    }
    contours.delete(); hierarchy.delete(); src.delete(); gray.delete(); blur.delete(); bin.delete();
    tiles.sort((a,b)=> a.rect.y===b.rect.y ? a.rect.x-b.rect.x : a.rect.y-b.rect.y);
    return tiles;
  }

  async function ocrFallback(canvas){
    try{
      let res = await Tesseract.recognize(canvas, 'eng', { config: 'tessedit_char_whitelist=0123456789 --psm 10' });
      let text = (res.data && res.data.text || '').trim();
      let m = text.match(/\b1[0-3]\b/);
      if(m) return parseInt(m[0],10);
      m = text.match(/\b[0-9]\b/);
      if(m) return parseInt(m[0],10);
    }catch(e){}
    return null;
  }
  async function classifyTile(canvas){
    const res = await predictClass(canvas);
    if(res && res.label!=='none'){
      const n = parseInt(res.label,10);
      const conf = res.confidences[res.label]||0;
      if (n>=1 && n<=13 && conf>=settings.conf) return n;
    }
    return await ocrFallback(canvas);
  }

  async function detectFromFile(file){
    const bmp = await createImageBitmap(file);
    const tiles = await segmentTiles(bmp);
    const results = [];
    for(const t of tiles){
      const v = await classifyTile(t.canvas);
      if(v!=null) results.push(v);
    }
    return results;
  }

  // ===== Game logic =====
  function startGame(){
    const names = ['#n0','#n1','#n2','#n3'].map(val).filter(Boolean);
    const list = names.length ? names : ['×©×—×§×Ÿ 1','×©×—×§×Ÿ 2'];
    state.players = list.map((n,i)=>({id:String(i+1), name:n, points:0}));
    save(); showGame();
  }
  function showGame(){ document.getElementById('s1').classList.add('hidden'); document.getElementById('s2').classList.remove('hidden'); render(); window.scrollTo({top:0,behavior:'smooth'}); }
  function backToNames(){ document.getElementById('s2').classList.add('hidden'); document.getElementById('s1').classList.remove('hidden'); }
  function addPoints(id,delta){ const p=state.players.find(x=>x.id===id); if(!p) return; p.points += delta; save(); render(); }
  function setPoints(id,val){ const p=state.players.find(x=>x.id===id); if(!p) return; p.points = val; save(); render(); }

  function render(){
    const board = document.getElementById('board'); board.innerHTML = '';
    const sorted = state.players.slice().sort((a,b)=> b.points-a.points);
    sorted.forEach((p,i)=>{
      const div = document.createElement('div'); div.className='chip';
      div.innerHTML = '<div class="rank">'+(i+1)+'</div><div>'+p.name+(i===0?' ğŸ‘‘':'')+'</div><div style="margin-inline-start:auto">'+p.points+' × ×§×³</div>';
      board.appendChild(div);
    });

    const panels = document.getElementById('panels'); panels.innerHTML='';
    state.players.forEach(p=>{
      const card = document.createElement('div'); card.className='card';
      const head = document.createElement('div'); head.className='row';
      const title = document.createElement('h3'); title.style.margin='0'; title.textContent = p.name;
      const mount = document.createElement('div'); mount.className='parsed'; mount.textContent='×‘×—×¨/×™ ×ª××•× ×” ×©×œ ×”×§×•×‘×™×•×ª.';
      const fileReplace = document.createElement('input'); fileReplace.type='file'; fileReplace.accept='image/*'; fileReplace.className='hidden';
      const fileAdd = document.createElement('input'); fileAdd.type='file'; fileAdd.accept='image/*'; fileAdd.className='hidden';
      const uploadBtn = document.createElement('button'); uploadBtn.className='btn-upload'; uploadBtn.textContent=' ×”×¢×œ×” ×ª××•× ×” (×”×—×œ×£)';
      const addBtn = document.createElement('button'); addBtn.className='btn-plus'; addBtn.textContent=' ×”×¢×œ×” ×•×¢×•×“ (×¦×‘×•×¨)';
      uploadBtn.onclick=()=> fileReplace.click();
      addBtn.onclick=()=> fileAdd.click();
      fileReplace.onchange=(e)=>{ const f=e.target.files[0]; if(f){ mount.textContent='×× ×ª×—â€¦'; detectFromFile(f).then(nums=>{ if(!nums.length){ mount.textContent='×œ× ×–×•×”×• ×§×•×‘×™×•×ª.'; return;} const s=nums.reduce((a,b)=>a+b,0); setPoints(p.id,s); mount.textContent='×–×•×”×•: '+nums.join(' + ')+' = '+s+' (×”×•×—×œ×£)'; }); e.target.value=''; } };
      fileAdd.onchange=(e)=>{ const f=e.target.files[0]; if(f){ mount.textContent='×× ×ª×—â€¦'; detectFromFile(f).then(nums=>{ if(!nums.length){ mount.textContent='×œ× ×–×•×”×• ×§×•×‘×™×•×ª.'; return;} const s=nums.reduce((a,b)=>a+b,0); addPoints(p.id,s); mount.textContent='×–×•×”×•: '+nums.join(' + ')+' = '+s+' (× ×•×¡×£)'; }); e.target.value=''; } };
      head.appendChild(title); head.appendChild(uploadBtn); head.appendChild(addBtn);
      card.appendChild(head); card.appendChild(fileReplace); card.appendChild(fileAdd);

      const meta = document.createElement('div'); meta.innerHTML = '× ×§×•×“×•×ª × ×•×›×—×™×•×ª: <span class="pill">'+p.points+'</span>';
      card.appendChild(meta);

      const ctrls = document.createElement('div'); ctrls.className='controls';
      const num = document.createElement('input'); num.type='number'; num.className='numbox'; num.placeholder='+/-';
      const go  = document.createElement('button'); go.textContent='×”×•×¡×£/×”×¤×—×ª'; go.onclick=()=>{ const d=Number(num.value); if(!Number.isNaN(d)&&num.value!==''){ addPoints(p.id,d); num.value=''; } };
      ctrls.appendChild(num); ctrls.appendChild(go);
      const minus10 = document.createElement('button'); minus10.textContent='-10'; minus10.onclick=()=>addPoints(p.id,-10); ctrls.appendChild(minus10);
      card.appendChild(ctrls);
      card.appendChild(mount);
      panels.appendChild(card);
    });
  }

  // Wire buttons (guarded with ?. to avoid null errors)
  document.getElementById('startBtn')?.addEventListener('click', startGame);
  document.getElementById('backBtn')?.addEventListener('click', backToNames);
  document.getElementById('resetBtn')?.addEventListener('click', ()=>{ if(confirm('×œ××¤×¡ ××ª ×›×œ ×”× ×§×•×“×•×ª?')){ state.players.forEach(p=>p.points=0); save(); render(); } });
  document.getElementById('toggleTrainer')?.addEventListener('click', ()=> document.getElementById('trainer').classList.toggle('hidden'));
  document.getElementById('addFromGallery')?.addEventListener('click', ()=>{
    const picker = document.getElementById('filePick');
    const cls = document.getElementById('cls').value;
    picker.onchange = async (e)=>{
      const files = Array.from(e.target.files);
      for(const f of files){
        const img = new Image(); img.src = URL.createObjectURL(f);
        await new Promise(res=> img.onload=res);
        await addExample(img, cls);
      }
      if(statusEl) statusEl.textContent = '× ×•×¡×¤×• ×“×•×’×××•×ª ×œ-'+cls;
      picker.value='';
    };
    picker.click();
  });
  document.getElementById('captureOne')?.addEventListener('click', async ()=>{
    const cls = document.getElementById('cls').value;
    try{
      const s = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}});
      const v = document.createElement('video');
      v.playsInline = true; v.muted = true; v.srcObject = s;
      await v.play();
      await new Promise(r=> setTimeout(r, 400));
      const c = document.createElement('canvas'); c.width=224; c.height=224;
      const ctx = c.getContext('2d');
      const vw = v.videoWidth, vh = v.videoHeight;
      const size = Math.min(vw,vh);
      ctx.drawImage(v, (vw-size)/2, (vh-size)/2, size, size, 0, 0, 224, 224);
      await addExample(c, cls);
      s.getTracks().forEach(t=> t.stop());
      if(statusEl) statusEl.textContent = '× ×•×¡×¤×” ×“×•×’××” ×œ-'+cls;
    }catch(e){
      alert('×‘×¢×™×™×ª ××¦×œ××”/×”×¨×©××”: ' + e.message);
    }
  });

  if(state.players && state.players.length){ showGame(); }
});
</script>
</body>
</html>
