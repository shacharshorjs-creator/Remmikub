<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Multi‑Tile Detect (Rummikub) – Demo</title>
<style>
  body{background:#0d1117;color:#e6f0ff;font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
  .wrap{max-width:980px;margin:18px auto;padding:0 14px}
  .row{display:flex;flex-wrap:wrap;gap:10px;align-items:center}
  .card{background:#0f1626;border:1px solid #22324f;border-radius:14px;padding:14px;margin:10px 0}
  .btn{background:#1a2a45;border:1px solid #2a3e63;color:#d7e1ff;border-radius:10px;padding:8px 12px;font-weight:600;cursor:pointer}
  .btn.alt{background:#143022;border-color:#235b3f}
  .btn.warn{background:#3b2222;border-color:#7b3a3a}
  input[type="file"]{display:none}
  .kbd{background:#0c1a30;border:1px solid #23416f;border-radius:6px;padding:1px 6px}
  label.file{display:inline-block}
  .pill{display:inline-block;padding:6px 10px;border-radius:10px;background:#0f1a2b;border:1px solid #223456;color:#8aa0c8}
  .grid{display:grid;grid-template-columns:1fr 1fr;gap:10px}
  @media(max-width:880px){ .grid{grid-template-columns:1fr} }
  .thumbs{display:grid;grid-template-columns:repeat(auto-fill,96px);gap:8px}
  .thumb{background:#0a121f;border:1px solid #223456;border-radius:10px;padding:6px;text-align:center}
  .thumb canvas{display:block;margin:0 auto 6px;border-radius:6px}
  .bar{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
  #ver{position:fixed;top:10px;left:10px;background:#122038;color:#cfe0ff;border:1px solid #1f3154;
       border-radius:12px;padding:6px 10px;font-weight:700;z-index:50}
  #log{width:100%;min-height:120px;background:#0b1322;border:1px solid #263659;border-radius:10px;color:#a7c0ff;padding:8px;white-space:pre-wrap}
  canvas#stage{max-width:100%;border-radius:12px;background:#0b1322;border:1px solid #283a60}
</style>
</head>
<body>
<div id="ver">vMD‑1.0</div>
<div class="wrap">
  <h1 style="margin:4px 0 0">זיהוי כמה קוביות בתמונה אחת</h1>
  <small class="pill">דמו עצמאי – אינו משנה את הקוד הקיים שלך</small>

  <div class="card">
    <div class="bar">
      <label class="btn file">
        📷 בחר תמונה מרובת קוביות
        <input id="fileMulti" type="file" accept="image/*">
      </label>
      <label class="btn alt file">
        📦 שחזר מודל KNN (JSON)
        <input id="fileModel" type="file" accept="application/json">
      </label>
      <button class="btn" id="btnUseGlobals" title="נסה להשתמש ב‑classifier/net גלובליים אם עמוד זה רץ בתוך האפליקציה שלך">השתמש במודל הגלובלי</button>
      <span id="badges" class="pill">TF: — • Net: — • KNN: —</span>
    </div>
    <div class="bar">
      <label>התעלם מצבע <input id="ignoreColor" type="checkbox" checked></label>
      <label>סף בינארי: <span class="kbd" id="thrVal">auto</span>
        <input id="thr" type="range" min="0" max="255" value="0">
      </label>
      <label>גודל מינימלי (פיקסלים): <span class="kbd" id="minAreaLbl">1600</span>
        <input id="minArea" type="range" min="200" max="20000" value="1600">
      </label>
      <label>כמות מרבית: <span class="kbd" id="maxCountLbl">12</span>
        <input id="maxCount" type="range" min="1" max="30" value="12">
      </label>
      <label>יחס צלעות מותר: <span class="kbd" id="aspectLbl">0.55–0.85</span>
        <input id="aspectMin" type="range" min="0.3" max="1.0" step="0.01" value="0.55">
        <input id="aspectMax" type="range" min="0.4" max="1.5" step="0.01" value="0.85">
      </label>
    </div>
  </div>

  <div class="grid">
    <div class="card">
      <h3 style="margin-top:0">תמונה + תיבות זיהוי</h3>
      <canvas id="stage" width="960" height="540"></canvas>
    </div>
    <div class="card">
      <h3 style="margin-top:0">קוביות שנחתכו (מסודרות)</h3>
      <div class="thumbs" id="thumbs"></div>
      <div style="margin-top:10px" class="bar">
        <span class="pill">זוהו: <b id="count">0</b></span>
        <span class="pill">סכום: <b id="sum">0</b></span>
      </div>
    </div>
  </div>

  <div class="card">
    <h3 style="margin-top:0">debug</h3>
    <textarea id="log" placeholder="log..."></textarea>
  </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/mobilenet@2.1.0"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/knn-classifier@1.2.2"></script>

<script>
let net=null, classifier=null, mobilenetVersion='2.1.0';

function log(s){ const el=document.getElementById('log'); el.value += (el.value?'\\n':'') + s; el.scrollTop = el.scrollHeight; }
function setBadges(){ const b = document.getElementById('badges'); b.textContent = `TF: ${tf.getBackend?.()||'?'} • Net: ${net?'✓':'—'} • KNN: ${classifier?'✓':'—'}`; }

async function ensureModels(){
  if(!net){ log('loading mobilenet...'); net = await mobilenet.load(); log('net ✓'); }
  if(!classifier){ classifier = knnClassifier.create(); log('knn ✓'); }
  setBadges();
}

function toGray(r,g,b){ return (r*0.299 + g*0.587 + b*0.114) |0; }

function otsuThreshold(gray, w, h){
  // Otsu's method (simple)
  const hist = new Array(256).fill(0);
  for(let i=0;i<gray.length;i++) hist[gray[i]]++;
  const total = w*h;
  let sum=0; for(let t=0;t<256;t++) sum += t*hist[t];
  let sumB=0, wB=0, wF=0, varMax=0, thr=0;
  for(let t=0;t<256;t++){
    wB += hist[t]; if(wB===0) continue;
    wF = total - wB; if(wF===0) break;
    sumB += t*hist[t];
    const mB = sumB / wB;
    const mF = (sum - sumB) / wF;
    const between = wB*wF*(mB-mF)*(mB-mF);
    if (between > varMax){ varMax = between; thr = t; }
  }
  return thr;
}

function segmentTiles(img, params){
  const cvs = document.getElementById('stage'), ctx = cvs.getContext('2d');
  // fit image to canvas
  const scale = Math.min(cvs.width/img.width, cvs.height/img.height);
  const nw = Math.round(img.width*scale), nh = Math.round(img.height*scale);
  const ox = Math.round((cvs.width - nw)/2), oy = Math.round((cvs.height - nh)/2);
  ctx.clearRect(0,0,cvs.width,cvs.height);
  ctx.drawImage(img, ox, oy, nw, nh);

  // get pixels
  const id = ctx.getImageData(ox, oy, nw, nh);
  const data = id.data;
  const gray = new Uint8ClampedArray(nw*nh);
  for(let y=0;y<nh;y++){
    for(let x=0;x<nw;x++){
      const i = (y*nw + x)*4;
      const r=data[i], g=data[i+1], b=data[i+2];
      gray[y*nw+x] = params.ignoreColor ? toGray(r,g,b) : Math.max(r,g,b); // או מקסימום ערוץ
    }
  }
  let thr = params.thr>0? params.thr : otsuThreshold(gray, nw, nh);
  document.getElementById('thrVal').textContent = params.thr>0? params.thr : `auto(${thr})`;

  // binary mask (tiles brighter on average)
  const bin = new Uint8Array(nw*nh);
  for(let i=0;i<gray.length;i++) bin[i] = gray[i] > thr ? 1 : 0;

  // Connected components (4-neigh)
  const labels = new Int32Array(nw*nh).fill(-1);
  const boxes = [];
  const qx = [], qy = [];
  let label=0;
  for(let y=0;y<nh;y++){
    for(let x=0;x<nw;x++){
      const idx = y*nw + x;
      if(bin[idx]===0 || labels[idx]!==-1) continue;
      // BFS
      let minx=x, miny=y, maxx=x, maxy=y, area=0;
      qx.length=0; qy.length=0; qx.push(x); qy.push(y); labels[idx]=label;
      while(qx.length){
        const cx = qx.pop(), cy = qy.pop();
        const cidx = cy*nw + cx; area++;
        if(cx<minx) minx=cx; if(cy<miny) miny=cy;
        if(cx>maxx) maxx=cx; if(cy>maxy) maxy=cy;
        // neighbors
        const nbs = [[1,0],[-1,0],[0,1],[0,-1]];
        for(const [dx,dy] of nbs){
          const nx=cx+dx, ny=cy+dy;
          if(nx<0||ny<0||nx>=nw||ny>=nh) continue;
          const nidx = ny*nw + nx;
          if(bin[nidx]===1 && labels[nidx]===-1){ labels[nidx]=label; qx.push(nx); qy.push(ny); }
        }
      }
      const bw = maxx-minx+1, bh = maxy-miny+1;
      const aspect = Math.min(bw,bh)/Math.max(bw,bh); // 1 = ריבוע; אריח רמי מעט מלבני
      if(area >= params.minArea && aspect>=params.aspectMin && aspect<=params.aspectMax){
        boxes.push({x:minx,y:miny,w:bw,h:bh,area,aspect});
      }
      label++;
    }
  }

  // sort boxes (left-to-right, then top)
  boxes.sort((a,b)=> a.y===b.y ? a.x-b.x : a.y-b.y);
  if(boxes.length>params.maxCount) boxes.length = params.maxCount;

  // draw boxes
  ctx.strokeStyle = '#28e0a4'; ctx.lineWidth = 2;
  boxes.forEach((b,i)=>{
    ctx.strokeRect(ox+b.x, oy+b.y, b.w, b.h);
    ctx.fillStyle='#0a2c22'; ctx.fillRect(ox+b.x, oy+b.y-16, 20, 16);
    ctx.fillStyle='#77ffd3'; ctx.fillText(String(i+1), ox+b.x+6, oy+b.y-4);
  });

  // return crop descriptors with mapping back to original canvas coords
  return {boxes, ox, oy, nw, nh, scale};
}

async function classifyCrops(img, seg){
  await ensureModels();
  const thumbs = document.getElementById('thumbs');
  thumbs.innerHTML='';
  let total=0;
  const ctx = document.getElementById('stage').getContext('2d');

  for(let i=0;i<seg.boxes.length;i++){
    const b = seg.boxes[i];
    // create crop canvas
    const c = document.createElement('canvas'); c.width=112; c.height=112;
    const cc = c.getContext('2d');
    // Slight padding to include full tile
    const pad = Math.floor(Math.min(b.w,b.h)*0.08);
    cc.drawImage(
      document.getElementById('stage'),
      seg.ox + b.x - pad, seg.oy + b.y - pad, b.w + pad*2, b.h + pad*2,
      0,0, c.width, c.height
    );

    // classify
    let num='—', conf='—';
    try{
      const feat = net.infer(c, 'conv_preds');
      const res  = await classifier.predictClass(feat, 3);
      if(res && res.label!=null){
        num = res.label;
        const cfs = Object.values(res.confidences||{});
        conf = Math.round(Math.max(...cfs)*100)+'%';
        const v = parseInt(num,10);
        if(Number.isFinite(v)) total += v;
      }
    }catch(err){
      log('classify error: '+(err?.message||err));
    }

    // show
    const box = document.createElement('div'); box.className='thumb';
    const tag = document.createElement('div'); tag.style.opacity=.85; tag.textContent = `#${i+1}: ${num} (${conf})`;
    box.appendChild(c); box.appendChild(tag);
    thumbs.appendChild(box);
  }
  document.getElementById('count').textContent = String(seg.boxes.length);
  document.getElementById('sum').textContent = String(total);
}

function readAsImage(file){
  return new Promise((resolve,reject)=>{
    const url = URL.createObjectURL(file);
    const img = new Image();
    img.onload = ()=> resolve({img, url});
    img.onerror = ()=> reject(new Error('cannot load image'));
    img.src = url;
  });
}

function tryUseGlobal(){
  try{
    if(!net && window.net){ net = window.net; }
    if(!classifier && window.classifier){ classifier = window.classifier; }
    setBadges();
    log('Using globals: net='+(!!net)+' classifier='+(!!classifier));
  }catch(err){ log('globals error: '+(err?.message||err)); }
}

async function restoreKnnFromJson(file){
  await ensureModels();
  const txt = await file.text();
  let obj = JSON.parse(txt);
  // accept both {label:[...flat]} or {label:{data:[],shape:[n,1024]}} style
  const ds = {};
  for(const [k,v] of Object.entries(obj)){
    if(Array.isArray(v)){
      const dim = 1024;
      const n = Math.floor(v.length/dim);
      ds[k] = tf.tensor2d(v, [n, dim]);
    }else if(v && Array.isArray(v.data) && Array.isArray(v.shape)){
      ds[k] = tf.tensor2d(v.data, v.shape);
    }else{
      log('skip label '+k+' (unknown format)');
    }
  }
  classifier.setClassifierDataset(ds);
  for(const t of Object.values(ds)){ t.dispose?.(); } // classifier keeps internal copies
  log('KNN restored ✓');
  setBadges();
}

document.getElementById('fileModel').onchange = (e)=>{
  if(e.target.files?.length){ restoreKnnFromJson(e.target.files[0]); }
};

document.getElementById('btnUseGlobals').onclick = tryUseGlobal;

document.getElementById('fileMulti').onchange = async (e)=>{
  if(!(e.target.files && e.target.files.length)) return;
  const file = e.target.files[0];
  const {img, url} = await readAsImage(file);
  const params = {
    ignoreColor: document.getElementById('ignoreColor').checked,
    thr: +document.getElementById('thr').value,
    minArea: +document.getElementById('minArea').value,
    maxCount: +document.getElementById('maxCount').value,
    aspectMin: +document.getElementById('aspectMin').value,
    aspectMax: +document.getElementById('aspectMax').value,
  };
  const seg = segmentTiles(img, params);
  await classifyCrops(img, seg);
  URL.revokeObjectURL(url);
};

// UI bindings for labels
['minArea','maxCount','aspectMin','aspectMax'].forEach(id=>{
  const el=document.getElementById(id);
  el.oninput = ()=>{
    if(id==='minArea') document.getElementById('minAreaLbl').textContent = el.value;
    if(id==='maxCount') document.getElementById('maxCountLbl').textContent = el.value;
    if(id==='aspectMin' || id==='aspectMax'){
      document.getElementById('aspectLbl').textContent = document.getElementById('aspectMin').value+'–'+document.getElementById('aspectMax').value;
    }
  };
});
</script>
</body>
</html>